{"posts":[{"title":"Python练习","text":"不定时更新Python的练习题 2023.11.1练习问题1：编写一个程序，要求用户输入一个正整数，然后计算该整数的阶乘并输出结果。阶乘是指将一个整数与小于它的所有正整数相乘的结果。例如，5的阶乘是5 * 4 * 3 * 2 * 1 = 120。 要求： 提示用户输入一个正整数。 检查用户输入是否是正整数，如果不是，显示错误消息并要求重新输入。 计算输入整数的阶乘。 输出计算结果。 12345678910111213141516171819#提示用户输入num = input(&quot;请阁下输入一个正整数：&quot;) #判断用户输入是否是正整数if num.isdigit(): num = int(num) if num &gt; 0: print(f&quot;{num}是一个正整数&quot;) else: print(f&quot;{num}不是正整数，请阁下重新输入&quot;)else: print(f&quot;{num}不是正整数，请阁下重新输入&quot;) #计算整数的阶乘result = 1for i in range(1, num+1): result *= iprint(f&quot;{num}的阶乘为:{result}&quot;) 问题2： 编写一个Python程序，要求用户输入一个字符串，然后判断这个字符串是否是回文字符串。回文字符串是指正着读和倒着读都一样的字符串，例如 “level”、”radar” 和 “madam” 都是回文字符串。 要求： 提示用户输入一个字符串。 忽略字符串中的空格，标点符号和大小写（将所有字符转换为小写）。 判断输入的字符串是否是回文字符串。 输出相应的结果，指出是否是回文字符串。 12345678910111213141516import re#提示用户输入user_input = input(&quot;请阁下输入一个字符串：&quot;)#移除空格，标点和大小写user_input = user_input.replace(&quot; &quot;, &quot;&quot;) #移除空格user_input = re.sub(r'[^\\w\\s]','',user_input) #移除符号标点user_input = user_input.lower() #转换为小写#判断输入的字符是否是回文字符串fan_input = user_input[::-1] #创建反向字符串if fan_input == user_input: #判断是否是回文字符串 print(f&quot;恭喜阁下，{user_input}是回文字符串！&quot;)else: print(f&quot;很抱歉，{user_input}并不是回文字符串&quot;) 2023.11.5练习问题1：写一个Python程序，找出一个列表中的所有奇数，并将它们存储在一个新的列表中。 要求： 创建一个函数，该函数接受一个整数列表作为参数。 函数应该返回一个新的列表，其中包含原列表中的所有奇数。 不要使用内置的filter函数或列表解析来完成任务。 123456789101112131415def find_odd_numbers(input_list): #定义奇数函数 odd_numbers = [] #形成一个列表 input_list = input_list.split(&quot;,&quot;) #对列表进行切片 input_list = [int(num.strip()) for num in input_list] #检查奇数 input_list = [int(num_str.strip()) for num_str in input_list] # 更改变量名 for num in input_list: #遍历列表 if num % 2 != 0: odd_numbers.append(num) return odd_numbersuser_input = input(&quot;请阁下输入一串列表(用，隔开): &quot;)result = find_odd_numbers(user_input)print(&quot;奇数列表：&quot;, result) 问题2：编写一个Python程序，计算斐波那契数列的第n个数字，其中n是非负整数。斐波那契数列的定义如下：1.第0个和第1个数字分别为0和1。2.从第2个数字开始，每个数字都是前两个数字之和 要求： 创建一个函数，接受一个非负整数n作为参数。 函数应该返回斐波那契数列的第n个数字。 请使用递归方式来解决这个问题。 12345678910111213141516171819202122#定义斐波那契数列的函数def fibonacci(n): if n &lt;= 0: return 0 elif n == 1: return 1 else: return fibonacci(n-1) + fibonacci(n-2)#提示用户输入user_input = input(&quot;请阁下输入一个非负整数&quot;)#测试用户输入的是否是一个非负整数try: user_input = int(user_input) if user_input &lt; 0: print(&quot;让你打非负整数你不听,你XX!&quot;) else: result = fibonacci(user_input)except ValueError: print(&quot;输入什么玩意儿，让你输入一个非负整数&quot;) 2023.11.6练习问题1：猜数字游戏 要求：编写一个Python程序，实现一个简单的猜数字游戏。程序随机生成一个1到100之间的整数，然后要求玩家猜这个数字，直到玩家猜中为止。程序需要提供反馈，告诉玩家他们的猜测是太高还是太低。最后，当玩家猜中数字时，显示猜测次数和祝贺消息。 123456789101112131415161718import randomdef guess_num(): real_num = random.randint(1,100) attempts = 0 while True: user_num = int(input(&quot;请猜测一下目标数字为(在1-100间选择)：&quot;)) attempts += 1 if user_num &lt; real_num: print(&quot;结果与猜测不符，有点小，请再试一次&quot;) elif user_num &gt; real_num: print(&quot;结果与猜测不符，有点大，请再试一次&quot;) else: print(f&quot;恭喜阁下猜中了！目标数字为{real_num}，与阁下猜测的{user_num}完全一致！您真是一个小天才！&quot;) breakguess_num() 问题2：查找最大元素 要求编写一个Python函数，接受一个包含整数的列表作为参数，然后找到列表中的最大元素，并返回该最大元素的值。 12345678910111213141516def find_max_element(lst): # 初始化最大元素为列表的第一个元素 max_element = lst[0] # 使用循环遍历列表中的每个元素 for num in lst: # 如果当前元素比最大元素大，更新最大元素的值 if num &gt; max_element: max_element = num # 返回最大元素的值 return max_element# 示例使用numbers = [12, 45, 62, 88, 34, 98, 75]result = find_max_element(numbers)print(f&quot;列表中的最大元素是 {result}&quot;) 2023.11.12练习问题1：简单的购物清单要求： 初始化一个空的购物清单。 提示用户选择操作：添加商品、显示购物清单或退出。 如果用户选择添加商品，程序应该提示用户输入商品名称和价格，然后将商品添加到购物清单。 如果用户选择显示购物清单，程序应该输出当前购物清单中的所有商品及其总价格。 如果用户选择退出，程序应该结束运行。 在每次循环后，再次显示操作选项。 123456789101112131415161718192021222324252627282930313233343536373839import randomdef menu(): print(&quot;欢迎使用购物清单程序!\\n操作选项：\\n1. 添加商品\\n2. 显示购物清单\\n3. 退出&quot;)def add(shopping_list): name = input(&quot;请输入商品的名称：&quot;) price = input(&quot;请输入商品的价格：&quot;) shopping_list[name] = price print(f&quot;{name}已添加至购物车 \\n &quot;)def display(shopping_list): if not shopping_list: print(&quot;购物车竟然是空的！再忙，也记得买点什么犒劳下自己&quot;) else: print(&quot;当前购物清单：&quot;) for name, price in shopping_list.items(): print(f&quot; {name}: {price}&quot;) total = sum(shopping_list.values()) print(f&quot;总价格为：{total} \\n&quot;)def main(): shopping_list = {} while True: menu() choice = input(&quot;请选择操作 (1/2/3): &quot;) if choice == '1': add(shopping_list) elif choice == '2': display(shopping_list) elif choice == '3': print(&quot;退出也没有，摇一摇等下又见面了&quot;) break else: print(&quot;你在说什么？ \\n&quot;)if __name__ == &quot;__main__&quot;: main() 2023.12.20练习问题1：猜单词游戏要求： 使用一个包含多个单词的列表作为单词库。 在游戏开始时，随机选择一个单词作为目标单词。 显示一个由下划线组成的部分单词，初始时下划线的位置与目标单词相对应。 允许玩家猜测字母，显示已经猜对的字母，并更新部分单词的显示。 显示玩家已经猜过的字母列表。 如果玩家在规定次数内猜对了整个单词，显示祝贺消息。如果猜错了6次，显示失败消息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import random# 创建词库def choose_word(): word_list = [&quot;python&quot;, &quot;programming&quot;, &quot;challenge&quot;, &quot;coding&quot;, &quot;computer&quot;] return random.choice(word_list)# 显示部分单词def display_partial_word(word, guessed_letters): partial_word = &quot;&quot; # 初始化字符串为空 for letter in word: # 遍历目标单词的每个字符 if letter in guessed_letters: # 如果字母已经在已猜过的字母列表中 partial_word += letter # 将字母添加到部分单词中 else: partial_word += &quot;_&quot; # 否则，用下划线代替未猜对的字母 return partial_word# 游戏主循环def main(): target_word = choose_word() guessed_letters = [] max_attempts = 6 #最大猜测次数 attempts = 0 #初始值 print(&quot;欢迎来到猜字母游戏!&quot;) print(display_partial_word(target_word, guessed_letters)) while True: guess = input(&quot;猜一个字母: &quot;).lower() if len(guess) != 1 or not guess.isalpha(): print(&quot;请输入一个有效的字母。&quot;) continue if guess in guessed_letters: print(&quot;你已经猜过这个字母了。&quot;) continue guessed_letters.append(guess) if guess not in target_word: attempts += 1 print(f&quot;猜错了！还剩余 {max_attempts - attempts} 次机会。&quot;) partial_word = display_partial_word(target_word, guessed_letters) print(partial_word) if &quot;_&quot; not in partial_word: print(&quot;恭喜你，你猜对了！&quot;) break if attempts == max_attempts: print(f&quot;很遗憾，你没有在规定次数内猜对。正确答案是: {target_word}&quot;) breakif __name__ == &quot;__main__&quot;: main() 2024.1.8练习问题1：学生成绩管理系统要求：你需要设计一个简单的学生成绩管理系统。系统应该包括以下功能： 添加学生：添加学生的姓名和成绩。 显示学生列表：显示所有学生的姓名和成绩。 搜索学生：通过学生姓名查找并显示其成绩。 计算平均成绩：计算并显示所有学生的平均成绩。 你可以选择使用列表、字典或其他数据结构来存储学生信息。为了简化问题，你可以假设每个学生的姓名都是唯一的。 解答12345678910111213141516171819202122232425262728293031323334353637383940# 学生列表创建students_list = []# 添加学生名字及成绩while True: name = input(&quot;请输入学生名字：&quot;) grade = float(input(&quot;请输入学生成绩：&quot;)) # 将输入转换为浮点数# 学生信息存储 students_info = (name, grade) students_list.append(students_info)# 询问用户是否继续添加学生信息 add_another = input(&quot;是否要添加另一个学生信息？(y/n): &quot;).lower() if add_another != 'y': break# 显示学生列表print(&quot;学生列表：&quot;)for student in students_list: print(f&quot;姓名: {student[0]}, 成绩: {student[1]}&quot;)# 计算平均成绩total_grade = sum(student[1] for student in students_list)average_grade = total_grade / len(students_list)print(f&quot;平均成绩：{average_grade}&quot;)# 搜索学生search_name = input(&quot;请输入要搜索的学生名字：&quot;)found = Falsefor student in students_list: if student[0] == search_name: print(f&quot;{search_name}的成绩是：{student[1]}&quot;) found = True breakif not found: print(f&quot;找不到{search_name}学生&quot;) 2024.1.24练习题目：电影评分统计要求：你需要设计一个电影评分统计系统。系统应该包括以下功能： 添加电影： 用户可以添加电影的名称和评分。 显示电影列表： 显示所有电影的名称和评分。 搜索电影： 通过电影名称查找并显示其评分。 计算平均评分： 计算并显示所有电影的平均评分。 推荐电影： 根据电影的平均评分，推荐一部用户可能喜欢的电影。推荐可以简单地选择平均评分较高的电影之一。 解答1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 电影列表建立movies_list = []# 添加电影名字while True: movies_name = input(&quot;请输入电影名字：&quot;) movies_evaluate = float(input(&quot;请阁下为电影评分：&quot;))# 存储电影 movies = (movies_name, movies_evaluate) movies_list.append(movies)# 询问用户是否继续添加信息 add_another = input(&quot;阁下是否还需要添加其他电影？(y/n): &quot;).lower() if add_another != 'y': break# 显示电影列表print(&quot;电影列表：&quot;)for movies in movies_list: print(f&quot;电影名：{movies[0]}, 评分：{movies[1]}&quot;)# 搜索电影search_movies = input(&quot;请阁下输入要搜索的电影名字：&quot;)found = Falsefor movies in movies_list: if movies[0] == search_movies: print(f&quot;{search_movies}的评分是：{movies[1]}&quot;) found = True breakif not found: print(f&quot;很抱歉，没有找到{search_movies}的相关信息&quot;)# 计算平均分total_grade = sum(movies[1] for movies in movies_list)average_grade = total_grade / len(movies_list)print(f&quot;所有电影的平均评分为：&quot;)# 推荐电影：recommend_movies = Nonehight_rating = 0for movies in movies_list: if movies[1] &gt; hight_rating: hight_rating = movies[1] recommend_movies = movies[0]if recommend_movies: print(f&quot;这是我根据平均分为阁下推荐的电影：{recommend_movies},{hight_rating}&quot;)else: print(&quot;很抱歉，暂无可推荐的电影&quot;) 2024.1.25题目：简单爬虫 - 获取新闻标题要求：编写一个 Python 程序，实现以下功能： 使用 Requests 库向某个新闻网站发起请求，获取网页的 HTML 内容。 使用 BeautifulSoup 库解析 HTML 内容，提取新闻标题。 将提取到的新闻标题打印输出或保存到文件中。 解答：12345678910111213141516171819202122232425262728import requestsfrom bs4 import BeautifulSoup# 替换成你选择的新闻网站的URLurl = &quot;https://www.bbc.com/news&quot;# 发起请求获取网页内容response = requests.get(url)# 检查请求是否成功if response.status_code == 200: html_content = response.text # 使用BeautifulSoup解析HTML soup = BeautifulSoup(html_content, 'html.parser') # 使用选择器提取新闻标题 # 根据实际HTML结构修改选择器 titles = soup.select('h3') # 打印或保存新闻标题 if titles: for title in titles: print(title.text.strip()) else: print(&quot;未找到符合选择器的标题元素。&quot;)else: print(f&quot;请求失败，状态码：{response.status_code}&quot;) 2024.5.6题目：计算字符串中的元音字母数量请编写一个Python程序，输入一个字符串，然后计算并输出该字符串中元音字母（a, e, i, o, u）的数量。要求程序对大小写字母均能正确处理。 例如：输入: “Hello World”输出: 3 提示：可以使用input()函数获取用户输入的字符串。为了简化问题，只需考虑英文字母a, e, i, o, u作为元音。可以使用字符串的.lower()或.upper()方法来统一处理大小写问题。利用循环遍历字符串中的每个字符，并检查是否是元音字母。 解答：12345678910111213141516171819#用户输入user_input = input(&quot;请阁下输入一个字符串：&quot;)#统一大小写input_string = user_input.lower() #定义元音字母zimu = 'aeiou'#初始化元音数zimu_count = 0#遍历字符串for char in input_string: if char in zimu: zimu_count += 1#输出print(&quot;元音字母的数量是：&quot;, zimu_count) 2024.5.7题目：统计列表中各元素的出现次数并输出结果编写一个Python程序，要求用户输入一系列整数（可以是空格分隔的一行输入），然后程序会统计每个数字出现的次数，并以字典形式输出。每个键值对中的键是数字，值是该数字出现的次数。 解答：123456789101112131415161718192021input_string = input(&quot;请输入一系列整数，用空格分隔：&quot;)# 切割try: numbers = [int(num) for num in input_string.split()]except ValueError: print(&quot;输入包含非整数，请确保所有输入都是整数。&quot;) exit()# 初始化numlist = {}# 遍历for num in numbers: if num in numlist: numlist[num] += 1 else: numlist[num] = 1 print(numlist) 2024.5.28题目：寻找列表中的最大和最小元素编写一个Python程序，要求用户输入一系列整数（用空格分隔）。然后程序会找到并输出这些整数中的最大值和最小值。 解答：123456789101112131415161718# 输入内容并判断输入是否合法while True: # 用户输入 usr_input = input(&quot;请阁下输入一系列整数，并用空格隔开：&quot;) try: # 分割成列表，并转换为整数列表 num_list = [int(num) for num in usr_input.split()] break except ValueError: print(&quot;错误！请阁下重新输入正确的整数并用空格隔开&quot;)# 寻找max和minmax_num = max(num_list)min_num = min(num_list)#输入max和minprint(&quot;最大值：&quot;, max_num)print(&quot;最小值：&quot;, min_num) 2024.5.30判断字符串是否是回文编写一个Python程序，要求用户输入一个字符串，然后判断该字符串是否是回文。如果是回文，输出“是回文”；否则，输出“不是回文”。 回文是指正读和反读都相同的字符串，例如“madam”或“racecar”。 解答：123456789101112131415161718192021# 说明print(&quot;阁下您好，感谢阁下使用此代码判断字符串是否是回文，请根据系统提示，帮助您解决问题。&quot;)print(&quot;提示：回文是指正读和反读都相同的字符串，例如“madam”或“racecar”。&quot;)#bodywhile True: # 输入字符串 usr_input = input(&quot;请输入您需要判断是否为回文的字符串(或按q退出)：&quot;) # 判断用户是否选择退出 if usr_input.lower() == 'q': print(&quot;感谢使用，程序已退出。&quot;) break # 切片反转操作 reversed_string = usr_input[::-1] # 判断是否是回文 if usr_input == reversed_string: print(&quot;这是回文字符串&quot;) else: print(&quot;这不是回文字符串&quot;) 计算一个列表中的平均值编写一个Python程序，要求用户输入一系列整数（用空格分隔），然后计算并输出这些整数的平均值。 解答：12345678910111213141516171819202122232425262728293031323334353637383940# 说明print(&quot;感谢您的使用，这是用于计算列表中的平均值的代码，请根据系统提示进行操作&quot;)# 用户输入并判断输入的正确性while True: # 用户输入 usr_input = input(&quot;请阁下输入一系列整数并用空格分隔(或按'q'退出)：&quot;) # 判断用户是否选择退出 if usr_input.lower() == 'q': print(&quot;感谢使用，程序已退出&quot;) break # 判断输入是否正确 try: # 分割列表，并转换为整数列表 num_list = [int(num) for num in usr_input.split()] # 检查列表是否为空 if not num_list: print(&quot;错误！列表为空，请重新输入整数。&quot;) continue # 计算平均值 total = 0 # 初始化 for num in num_list: # 计算总和 total += num # 计算平均值 num_count = len(num_list) # 列出个数 # 算平均值 average_num = total / num_count # 输出结果 print(&quot;平均值为：&quot;, average_num) except ValueError: print(&quot;错误！请阁下重新输入正确的整数并用空格隔开！&quot;) 2024.6.1题目：学生成绩管理系统编写一个Python程序，实现一个简单的学生成绩管理系统。该系统可以让用户输入多个学生的姓名和成绩，并计算每个学生的平均成绩。最终，输出所有学生的平均成绩。 解答：12345678910111213141516171819202122232425262728293031323334# 存储学生成绩的空字典student_scores = {}# 判断用户输入及正确性while True: # 用户输入 usr_input = input(&quot;要求用户输入学生姓名和成绩，格式为 姓名: 成绩1, 成绩2, 成绩3(或按'q'退出):&quot;) # 判断是否选择退出 if usr_input.lower() == 'q': print(&quot;感谢使用，已退出&quot;) break # 分割输入数据为姓名和成绩部分 try: name, scores_str = usr_input.split(':') except ValueError: print(&quot;输入格式错误，请按照格式：姓名: 成绩1, 成绩2, 成绩3&quot;) continue # 分割成绩字符串，并转换为整数列表 try: scores = [int(score.strip()) for score in scores_str.split(',')] except ValueError: print(&quot;成绩应为整数，请重新输入。&quot;) continue # 将姓名和成绩存储到字典中 student_scores[name] = scores# 计算并输出每个学生的平均成绩for name, scores in student_scores.items(): average_score = sum(scores) / len(scores) print(f&quot;{name} 的平均成绩为 {average_score:.2f}&quot;) 2024.6.7题目：统计字符串中各字符的出现次数编写一个Python程序，要求用户输入一个字符串，统计并输出该字符串中每个字符的出现次数。 解答：12345678910111213141516# 用户输入usr_input = input(&quot;请输入一个字符串：&quot;)# 初始化字典char_count = {}# 遍历输入for char in usr_input: if char in char_count: char_count[char] += 1 else: char_count[char] = 1# 输出for char, count in char_count.items(): print(f&quot;{char}:{char_count}&quot;) 2024.6.8题目：筛选出列表中的素数编写一个Python程序，要求用户输入一系列整数（用空格分隔），然后从这些整数中筛选出所有的素数，并输出这些素数。 解答：123456789101112131415161718192021222324252627# 用户输入usr_input = input(&quot;请输入一系列整数（用空格分隔）：&quot;)# 定义素数的函数def Prime_num(n): if n &gt; 1: for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False return True else: return False# 切片numbers = [int(num) for num in usr_input.split()]# 初始化列表primes = []# 遍历整数列表，筛选出所有的素数for num in numbers: if Prime_num(num): primes.append(num)# 输出筛选出的素数print(&quot;素数有：&quot;, ' '.join(map(str, primes)))","link":"/2023/11/01/Python%E7%BB%83%E4%B9%A0/"},{"title":"异步FIFO","text":"基于FIFO基础的知识，进一步学习什么是异步FIFO，除了基础知识外，还会增加verilog代码和波形图仿真。 计划有UVM验证，做不做得出来再说 基础知识参考视频：https://www.youtube.com/watch?v=mGREY8u9ELs&amp;t 异步FIFO是一种用于解决数据在不同时钟域之间安全传输的电路模块。你可以想象它像一个临时的数据仓库，一端负责接收数据，另一端负责发送数据，但这两端的工作节奏完全不同步——比如一端可能跑得飞快，而另一端慢悠悠的，就像两个人用不同的速度传递物品。这时候异步FIFO就充当了缓冲区的角色，确保快的一方不会把数据硬塞给慢的一方导致丢失，慢的一方也不会因为来不及取数据而卡住整个系统。 它的核心难点在于协调两个不同步的时钟。比如当写入端以高频时钟快速存入数据时，读取端可能用低频时钟慢慢读取，这时候需要巧妙的设计来避免读写指针冲突。常用的方法是用格雷码来表示指针，这种编码每次变化只改动一个比特位，能大幅降低跨时钟域同步时出现中间态错误的风险。你可能会在处理器与外设通信，或者芯片内部模块交互的场景中见到它，就像两个说不同方言的人通过翻译器顺畅对话一样。 操作步骤1.写入数据当外部电路需要写入数据时，写使能信号（这破翻译每次看到都想骂人，我念书的时候就一直搞不懂什么是使能。搞半天原来就是请求信号/启动信号Enable）就会被拉高。接着数据就会被放入FIFO的存储单元，同时写指针会向向前移动一步。 注：这里的写指针的移动速度由写时钟决定 2.同步读指针到写时钟域读指针原本属于读时钟域，但是需要告诉写端的朋友们“嘿，我读到第X个数据啦！”，否则写入端就不知道前面是否还有位置可以写入。就像你有个停车场管理员朋友，你要听他打电话缺人那里是否有停车位，你才能开车去找车位。 在数字电路中，两级触发器（或格雷码转换）就是起到电话的作用，电话将读指针同步到写时钟域。这时候写域的朋友就可以同步读域的情况了。 3.判断FIFO是否已经满了这里在基础部分已经详细讲过了 “传送门“ 4.读取数据当外部电路需要读取数据时，读使能信号（就是读的请求信号）会被拉高。数据从当前读指针指向的位置取出，同时读指针向前移动一步。读指针的移动速度由读时钟决定，可能与写时钟完全不同步。 5.同步写指针到读时钟域写指针需要被同步到读时钟域，让读端知道“写端已经写到哪里了”，否则读端可能读到无效数据。 这时候就需要我们的空信号闪亮登场：读端比较同步后的写指针和当前读指针。如果两者完全相等，说明FIFO已空，停止读取。 形象表达想象一个环形传送带： 写端工人（快时钟） 不断往传送带上放包裹（数据），但需要时不时看一眼对面发来的“读端进度表”（同步后的读指针），决定是否还能继续放。 读端工人（慢时钟） 按自己的节奏取包裹，同时定期向写端汇报“我取到第几个了”（同步后的写指针）。 如果写端太快，传送带放满时会暂停；如果读端太快，发现传送带空了也会暂停。两者通过“进度表”间接协调，即使速度不同也不会出错。 verilog代码来了来了，开始写代码仿真了！！！ 食用说明稍后会被放入仓库中，点击”传送门“可查看，只需要克隆至你的本地即可。 文档中会有6个文件：顶层模块(async_fifo.v)、存储器模块(fifo_memory.v)、写控制模块(write_controller.v)、读控制模块(read_controller.v)、跨时钟同步模块(sync_ptr.v)、TB模块(testbench.v) 代码内容仓库地址：https://github.com/HauUhang/Asynchronous-FIFO async_fifo.v fifo_memory.v write_controller.v read_controller.v sync_ptr.v testbench.v 写代码过程中的疑问和学习(1)write_ctrl写代码的逻辑是什么？ 首先要写信号： 📥 Inputs（来自哪里？） 写时钟信号【提示：FIFO 是异步的，写和读时钟分开，写控制模块用哪个时钟？】 写使能信号（是否写入）【提示：这个信号由外部模块控制，用来决定是否尝试写数据。】 FIFO已满标志？【提示：如果FIFO满了，还能写吗？这个信息从哪里来？你需要接收它还是计算它？】 读指针（同步过来的）【提示：你是否需要判断“满”？那你要和谁比较？异步域的信号可以直接比较吗？】 📤 Outputs（你要输出给谁？） 写地址（写指针）【提示：你要输出写地址给 RAM，同时也可能输出一个格雷码版本用于跨时钟同步。】 写指针（格雷码）【提示：异步FIFO通常会输出一个“同步友好”的写指针给读域。】 满信号（FIFO full）【提示：你是否要计算 FIFO 是否满？满的时候外部就不该写了。】 接着是逻辑异步FIFO的逻辑是这样的： 1234567891011121314151617 +--------------------+wen &amp; ~wfull | | ----------&gt;+ ① wptr_bin | | (计数器递增逻辑) | +--------------------+ | v +---------------------+ |② assign waddr | |waddr = wptr_bin[2:0]| +---------------------+ | v +-----------------------------+ |③ assign wptr_gray | |wptr_gray = wptr_bin ^ (&gt;&gt;1) | +-----------------------------+ 写指针（二进制）逻辑 写地址输出 写指针的格雷码形式 为什么在write_ctrl.v中我使用的是wire，而不是reg？因为根据FIFO基础中描述，我提到full= {~wptr[3],wptr[2:0]}=={rptr[3:0]}，这是一种组合逻辑，就要用wire 波形图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556`timescale 1ns/1psmodule tb_write_ctrl; reg wclk; reg wrst; reg wen; reg [2:0] rptr_gray_sync; wire [2:0] waddr; wire [2:0] wptr_gray; wire wfull; // 实例化 wirte_ctrl uut( .wclk(wclk), .wrst(wrst), .wen(wen), .rptr_gray_sync(rptr_gray_sync), .waddr(waddr), .wptr_gray(wptr_gray), .wfull(wfull) ); // 生成时钟 always #5 wclk = ~wclk; initial begin $dumpfile(&quot;wave.vcd&quot;); // 生成波形文件 (iverilog) $dumpvars(0, tb_write_ctrl); // 初始化 wclk = 0; wrst = 1; wen = 0; rptr_gray_sync = 3'b000; // 复位一段时间 #20; wrst = 0; // 写几次数据 #10; wen = 1; repeat(10) #10; // 模拟FIFO满 rptr_gray_sync = 3'b110; // 可以调整为和wptr_gray_full一致的值，观察wfull变化 // 写使能继续，看是否被禁止写 repeat(4) #10; // 结束 wen = 0; #50; $finish; endendmodule (2)read_ctrl这个模块的代码逻辑是什么？和写代码的很像，就几乎把w变成r就行了，不多赘述 (3)dual_port_ram我不太懂[7:0]和[2:0]究竟是什么，我想要一个8-deep的FIFO在 Verilog 中，[a:b] 是位宽定义，表示这个信号有多少位（bit）[7:0] 表示一共有 8 位（bit） 可以表示 0 到 255 的数（1 byte）[2:0] 表示一共有 3 位（bit） 可以表示 0 到 7（8个地址） 为什么这个里面不用wrst和rrst因为这个模块只是一个 纯存储器（memory）模块，RAM 本身是：同步写、同步读；没有“状态”需要复位；读写操作全靠 wen/ren + clk 控制；数据存在 RAM 的数组里（如 mem[0:7]），不受 reset 控制清空 mem[waddr] &lt;= wdata 的意思是wdata赋值给men的waddr中吗？在硬件中你可以把 mem[…] 看成一个可以存很多小值的“储物柜”，waddr 就是柜子号，wdata 是你放进去的东西。 testbench12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576`timescale 1ns/1psmodule tb_dual_port_ram; // 定义测试用的信号 reg wclk, wen; reg [2:0] waddr, wdata; reg rclk, ren; reg [2:0] raddr; wire [2:0] rdata; // 实例化 DUT（Design Under Test） dual_port_ram dut ( .wclk(wclk), .wen(wen), .waddr(waddr), .wdata(wdata), .rclk(rclk), .ren(ren), .raddr(raddr), .rdata(rdata) ); // 写时钟：周期 50ns initial begin wclk = 0; forever #25 wclk = ~wclk; end // 读时钟：周期 60ns initial begin rclk = 0; forever #30 rclk = ~rclk; end // 主测试流程 initial begin // 初始值 wen = 0; waddr = 3'd0; wdata = 3'd0; ren = 0; raddr = 3'd0; #50; // 写数据到地址 3：写入值 5 waddr = 3'd3; wdata = 3'd5; wen = 1; #50; wen = 0; // 写数据到地址 4：写入值 7 waddr = 3'd4; wdata = 3'd7; wen = 1; #50; wen = 0; // 读地址 3，应该读到 5 raddr = 3'd3; ren = 1; #60; ren = 0; // 读地址 4，应该读到 7 raddr = 3'd4; ren = 1; #60; ren = 0; // 结束仿真 #100; $stop; endendmodule 波形图 (4)sync_graytestbench123456789101112131415161718192021222324252627282930313233343536373839404142`timescale 1ns/1psmodule tb_sync_gray; reg clk; reg rst; reg gray_in; wire gray_out; // 实例化你的模块 sync_gray dut ( .clk(clk), .rst(rst), .gray_in(gray_in), .gray_out(gray_out) ); // 生成时钟 always #5 clk = ~clk; // 10ns周期 initial begin // 初始化信号 clk = 0; rst = 1; gray_in = 0; // 复位 #10; rst = 0; // 输入信号变化 #15 gray_in = 1; #20 gray_in = 0; #20 gray_in = 1; #30 gray_in = 0; // 模拟结束 #50; $stop; endendmodule 波形图","link":"/2025/04/07/Asynchronous-FIFO/"},{"title":"FIFO基础","text":"FIFO系列旨在教笨蛋自己，所以可能会有废话和吐槽，以及出现反复的说明。 基础知识参考这个视频https://www.youtube.com/watch?v=dCj5HAnaCd8 FIFO是什么？FIFO(First input First Output)：先进先出，先写入的数据先读取 为什么我们需要fifoFIFO的种类同步FIFO和异步FIFO 格雷码格雷码是任意两个相邻数的代码只有一位二进制数不同的编码，这样说太复杂看不懂，下面用3位二进制的表来说明： 十进制 ( $B_2$ ) ( $B_1$ ) ( $B_0$ ) 0 0 0 0 1 0 0 1 2 0 1 0 3 0 1 1 4 1 0 0 5 1 0 1 6 1 1 0 7 1 1 1 由此表我们可以看到3→4的 $B_2$ $B_1$ $B_0$ 都发生了变化，这种变化可能会导致亚稳态的出现。为了防止这种情况的发生，我们将引入格雷码的概念。 格雷码的规则是: 格雷码位 转换规则（异或表示） 转换规则（加法表示） ( $G_2$ ) ( $G_2 = B_2$ ) ( $G_2 = B_2$) ( $G_1$ ) ( $G_1 = B_2 \\oplus B_1$ ) ( $G_1 = B_2 + B_1$ ) ( $G_0$ ) ( $G_0 = B_1 \\oplus B_0$ ) ( $G_0 = B_1 + B_0$ ) 所以它的格雷码转换如下： 十进制 ($ G_2 $) ( $G_1$ ) ( $G_0$ ) 0 0 0 0 1 0 0 1 2 0 1 1 3 0 1 0 4 1 1 0 5 1 1 1 6 1 0 1 7 1 0 0 FIFO的理解FIFO结构 wptr: 写指针 rptr: 读指针 full: 满信号 empty: 空信号 FIFO的运行 初始：rst（复位）过一次后wptr和rptr会在初始的位置（0地址位）上，意思是初始化后大家都从零开始。 开始写入：现在假设一直在写入数据，从0一直写到7。 写满：当wptr写到7就代表FIFO现在是满(full)的状态，rptr读指针现在还是0（因为没有操作）。 写满后写指针：写满后+1，即(111+1=1000)，wptr会重新回到0(因为FIFO只看$B_2$$B_1$$B_0$的数据，即000)，此时wptr和rptr会重合 ——FIFO提问：你的wptr和rptr都是0了，我怎么知道是full还是empty?—— 什么时候是空信号(empty)?即 wptr=rptr【我靠你这不矛盾吗？上面刚说wptr和rptr重合了，明明已经把7个位置都沾满了咋还说我是空的？】为了处理这个问题，还需要再添加一个地址位来处理。 多的地址位：上面我们可以看到写满后+1地址位变成了4个(111+1=1000)，多出来的1就是我们的解题关键了 满信号(full)的条件：wptr的3位与rptr的3位相同(1[000]和0[000]) + wptr多出来的地址位取反与rptr相同([1]000和[0]000):full= {~wptr[3],wptr[2:0]}=={rptr[3:0]}此时我们再把上面的空信号满足条件补充一下：empty= wptr[3:0]==rptr[3:0] 空信号(empty)也滚了一周后：上面读满一次让空信号(empty)也+1了，后面的其实也不用担心，因为满信号(full)读满+1就变成0了，如果读满只会和空信号又正好相反。如果FIFO为空，则无法从中读取信号","link":"/2025/04/05/FIFO_Basics/"},{"title":"Markdown常用命令","text":"学习如何使用Markdown语言 2022.9.5今天想学习如何插入图片和代码表示： 代码查了一下是代码表示为tab上面的那个 成功啦 图片图片为为![名称](地址)，试下： 成功啦！ 2022.9.6今天学习下如何使用LaTeX公式，代码和注释： 公式：如果有文章需要开启LaTeX，记得在开头加上mathjax: ture 貌似和LaTeX没有什么变化，一个美元是文本中的公式，两个美元是换行单独一行的公式,不好意思这里没办法打符号给大家看，用了转义符也没有显示。 这里另外说一点，如果特殊符号转义只要在前面加\\就可以了。 试一下写个欧拉公式： $$ e^{i\\pi }+1=0 $$ 成功啦！ 代码方法1：用tab键直接实现：测试一下： print&quot;hello world!&quot; 成功啦！ 方法2：用```包裹代码：测试一下： 1print&quot;hello world!&quot; 成功啦！ 写注释有几张方法，不过写一个最简单的就好了：&lt;！--写注释--&gt; 测试一下： 成功啦！哈哈哈当然你们看不到！ 2022.9.7今天试着插入图片，之前插入的图片来源于Twitter，我今天试试Baidu的和本地的，看下能不能成功： Baidu图片插入图片为为![名称](地址)，试下： 成功啦！ 本地图片插入1.试了下base64转码转码地址这个是可以成功的，但是一大串代码放在我的md里面我看着非常难受，所以我试下用其他的方法； 2.直接把图片放在一个文件夹里试试： 可以直接复制图片至文章中 成功了！ 2022.9.8今天主要是弄了优化，实际上有些bug，无语了 2022.9.10中秋节快乐！ 昨天忘记记录了，不过也没干什么事情，出去玩了哈哈哈哈 今天美化了一下我的blog，好看多了哈哈哈哈 置顶文章如果需要对某篇文章进行置顶，只需要加入sticky: 1就可，详细可看Myblog已经置顶！ 成功啦！ 给文章加封面在开头加入cover: (图片地址) 成功啦！ 2023.3.27久违的更新，补充一下对文章的加密 准备工作（我的已完成）1npm install hexo-blog-encrypt --save 把代码放在文章顶部12password: testmessage: 测试加密，这里的密码是：test 我以“量子力学”这篇为例试验一下： 成功了！ 2023.12.20如何改变字颜色 红字 Markdown三线表Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 语法格式如下： 表头 表头 单元格 单元格 单元格 单元格 我们可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。 2025.1.5超链接超链接Markdown语法代码：[超链接显示名](超链接地址 &quot;超链接title&quot;)","link":"/2022/09/03/Markdown%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"},{"title":"git学习","text":"学习git语言 git日常使用常用命令github仓库git到本地，更新并上传 新建一个仓库 将仓库clone至本地任意位置，代码如下：(后面的地址可在GitHub上复制) git clone git@github.com:用户名/仓库名.git 将代码放入该文件/更新代码 使用以下命令： 1234git add .git commit -m&quot;注释内容&quot;git push https://github.com/用户名/仓库名.gitgit pull git学习(书)第I章 git是什么git能解决什么？git，是版本管理系统(时光机) 可以回到过去的状态 对于同一个文件可以多人协助修改 能记录修改源代码的原因 作为交流场所的GitHub和Bitbucket 相互之间检查代码 讨论前端样式和功能的实现 共享设计前后过程，相互提意见 第II章 我独自学习准备下载SourceTree 创建仓库正常操作 提交 添加一个TXT或是其他的，sourcetree都会感觉到 点击“暂存所有” 提交 继续积累历史记录(先暂存再提交) 记得添加注释 用checkout移动提交执行checkout可以让操作目录中的文件变成指定某个时刻文件的状态 第III章 多人协作使用git复制练习用仓库怎么复制？1.复刻；2，克隆一个是复制到GitHub上，一个是复制到本地上 复刻：指复制他人公开的远程仓库到自己账号中 克隆：把远程仓库复制到本地 创建并行世界(分支) 分支是什么？分支是一个指向提交对象可变指针。指针的意思就是“现在” 移动分支可以用checkout来让自己移动到任意一次提交 master是什么？最开始就存在的分支，就像河流的“干流” 合并分支merge可以让分支进行合并 推送上传数据，推送 拉取想要下载并反映到本地仓库的时候就是拉取 有冲突怎么办 冲突是什么？在同一行代码在同一时间被不同的人修改时发生的状况 从拉取请求到合并想把自己的代码同步到fork源仓库中，用拉取请求(pull request) git实践学习基础篇 git commit是Git 仓库中的提交记录保存 git branch 名字是创建分支 git checkout &lt;name&gt;让我们在提交修改之前先切换到新的分支上 如果你想创建一个新的分支同时切换到新创建的分支的话，可以通过git checkout -b &lt;your-branch-name&gt;来实现。 将两个分支合并到一起方法1：git merge 将两个分支合并到一起方法2：git rebase 高级篇 HEAD是一个对当前所在分支的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。 HEAD总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变HEAD的指向开始的。 用git log来查查看提交记录的哈希值 操作符 (^)。把这个符号加在引用名称的后面，表示让 Git 寻找指定提交记录的 parent 提交。 ~&lt;num&gt;一次后退num步 我使用相对引用最多的就是移动分支。可以直接使用 -f 选项让分支指向另一个提交。例如:git branch -f main HEAD~3。上面的命令会将 main 分支强制指向 HEAD 的第 3 级 parent 提交。 git reset通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”","link":"/2023/12/16/git%E5%AD%A6%E4%B9%A0/"},{"title":"Python爬虫","text":"学习Python爬虫 静态网页爬取requests利用代码requests.get(URL)可以获取URL的内容 动态网页爬取学习初步实践 将豆瓣top250的电影爬出来 12345678910111213141516from bs4 import BeautifulSoupimport requests# 如果没有headers就会报418错误，418错误就是只想服务浏览器用户，所以用headers伪装成浏览器用户headers = { &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36&quot;}for start_num in range(0, 250, 25): # 翻页 response = requests.get(f&quot;https://movie.douban.com/top250?start={start_num}&quot;, headers=headers) html = response.text soup = BeautifulSoup(html, &quot;html.parser&quot;) all_titles = soup.findAll(&quot;span&quot;, attrs={&quot;class&quot;: &quot;title&quot;}) for title in all_titles: title_string = title.string if &quot;/&quot; not in title_string: print(title_string) 用requests爬取博客信息 123456import requestsr = requests.get('https://github.com/HauUhang') #发送请求m = r.status_code #返回码print(m) #显示码(结果为200成功)","link":"/2024/01/26/Python%E7%88%AC%E8%99%AB/"},{"title":"Verilog学习","text":"基于《HDL数字系统设计与实践》一书的Verilog学习 verilog HDL 层次化设计模块和端口 模块=模块名定义+端口描述+内部功能逻辑 逻辑功能描述：变量声明、数据流描述语句、门级实例化描述语句、行为描述语句、任务与函数。 关键词：module定义模块名字；input、output指定端口方向；endmodule结束模块描述。 模块定义格式：1234module 模块名端口定义......unmodule 端口定义：有两种格式 普通风格 1234module 模块名input [位宽-1: 0] 端口名1，端口名2 output [位宽-1: 0] 端口3 inout [位宽-1: 0]端口4 ANSI C风格 12345module 模块名( input [位宽-1: 0] 端口名1，端口名2 output [位宽-1: 0] 端口3 inout [位宽-1: 0]端口4 ); 实例化：不允许嵌套，模块之间只能通过实例化 层次化设计思想 自顶向下类似于根据一张图纸造物 自底向上类似于根据材料造物，可以是已知也可以是未知的 Testbench概念用于测试设计的电路的功能是否正常 verilog HDL基本语法词法约定 空白符：空格\\b，制表\\t和换行 注释：单行//，多行*/.../*(不允许嵌套) 操作符：单目操作符~，双目操作符+，三目操作符? 标识符： 第一个字符是字母或下划线 区分大小写 转义\\ 空白符结束 关键字：均为小写 数据类型– 线网：除tri和reg所有网线类型不能存储数据值– 变量：抽象的数据存储单元 逻辑值与常量 基本值：0/1真假，x未知，z高阻(不分大小写) 整数：二进制、十进制、十六进制、八进制 格式：[位宽]'[进制][数值] 负数：加负号 实数：十进制和科学计数法(可用e或E表示) 逻辑强度：supply最强，highz最弱 线网类型：wire和tri最常见 格式：wire [7:0] datain, dataoutt(*两个8位的wire数据)【这是举例】 变量类型：reg类型、integer型、real型、time型 向量：位宽大于1 数组：数组中的每一个元素可以是标量也可以是向量 参数：defparam语句(同样不可嵌套) 表达式 操作数 算术操作符：单双目操作数。单目+ -表正负，双目* / + -运算符号 逻辑操作符：逻辑与&amp;&amp;，逻辑或||，逻辑非! 关系操作符：&gt; &lt; &gt;= &lt;= 相等操作符：逻辑相等==，逻辑不等!=，逻辑全等===，逻辑非全等!== 按位操作符：反~，与&amp;，或|，异或^，同或^~, ~^ 缩减操作符：缩减与&amp;，缩减与非-&amp;，缩减或|，缩减或非~|，缩减异或^，缩减同或~^, ^~ 位移操作：右移&gt;&gt;，左移&lt;&lt;，算术左移&lt;&lt;&lt;，算术右移&gt;&gt;&gt; 拼接操作符：格式{操作1，操作2，操作3，...，操作n} 条件操作符：根据条件表达式的值从两个表达式中选择一个表达式作为输出结果，格式条件表达式? 真表达式 ： 假表达式 Verilog HDL行为描述Verilog HDL基本描述形式 数据流描述方法1assing [延迟] wire类型 = 表达式 行为描述方式两种语句：initial和always1234567always @(事件控制列表) begin···end或intial begin···end 层次化描述方式1模块名 实例名 结构化过程语句initial和always语句不能相互嵌套使用 initial语句从仿真的0时刻开始，只执行一次。12345678reg a, b, c; //initial中只有一条赋值语句initial a = 1'b0; //若含多条赋值语句，需要begin endinitial begin b = 1'b0; c = 1'b0;end always语句从仿真的0时刻开始，会重新执行命令1234reg a;initial a = 0;always #50 a =-a;//从0开始，每隔50个时间单位的反复操作 顺序块和并行块 顺序块：按书写顺讯依次执行 并行块：fork是同时开始 块语句的其他特点 嵌套块 命名块 过程赋值语句 阻塞赋值语句用=作为赋值符，按顺序执行1234567reg a, b;initial begin a = 1'b0; b = 1'b0; #10 a = 1'b1; //阻塞赋值语句对a赋新值，a变为1后才继续执行后面的命令 b = a;end 非阻塞赋值语句用&lt;=作为赋值符，不会阻塞同一个块语句中的其他语句的执行1234567reg a, b;initial begin a = 1'b0; b = 1'b0; #10 a &lt;= 1'b1; //用非阻塞赋值语句赋值，赋值还未完成先完成后面的语句 b &lt;= a; //由于a的赋值未完成，所以b的值还是0end 条件语句有三种情况，if表达式，if-else表达式，if-else if表达式。注意，这里容易弄混，一定要搞清楚。 多路分支语句当分支特别多时，if else语句非常不好用，就可以使用case语句case语句的关键词：case default endcase 格式如下 123456case(表达式) 分支表达式1: 语句1 分支表达式2: 语句2 ··· default: 默认语句 endcase 条件语句和多路分支语句的比较if...else语句有优先级，而case语句没有，是并行的关系。 循环语句 while循环12while(条件表达式) 语句： 当表示式为真时，则循环执行里面的雨具；如果为假，中止循环并跳出while。如果while中表达式的值为x或z时，当作假处理。 for循环1for(循环变量初值;循环结束条件;循环变量增值) 在for中，C语言有i++，而verilog没有，改成i=i+1 repeat循环1repeat(循环次数表达式) forever循环 时序控制 延迟控制分为常规和内嵌，两者区别为：常规是整个语句执行后，在推迟的时间后，赋值语句开始计算；内嵌是开始执行时刻就立即计算表达式右边的值，此值会一直保持至延迟结束。 常规延迟# [延迟值] 语句 内嵌延迟语句 #[延迟值] 事件控制发生某个事件(变量、线网信号或表达式的值发生变化)之后，整个逻辑发生变化 边沿敏感事件控制用边缘敏感符号@，格式为12@ 事件 语句; 这里有个关键字:posedge(上升沿跳变)/negedge(下降沿跳变) 记住即可如果出现了多个敏感事件，则用or或者,即可 电平敏感事件控制以信号值变化的边沿为标志的，即一定要达到指定信号的某个值的变化边沿才会触发执行，关键字为wait1wait(事件) 语句; 当事件为真时，后面的语句才会执行 时序控制语句在综合代码中的应用在进行电路综合时，延迟控制语句会被综合工具自动忽略，当作无延迟处理 组合逻辑建模数字电路建模方式电路与代码的一一对应关系 组合逻辑的门级描述与门(and)、与非门(nand)、或门(or)、或非门(nor)、异或门(xor)、同或门(xnor)、缓冲器(buf)、非门(not)、三台缓冲器控制信号低电平有效(bufif0)、三台缓冲器控制信号高电平有效(bufif1)、三态非门控制信号低电平有效(notif0)、三态非门控制信号高电平有效(notif1) 组合逻辑的数据流描述 连续赋值语句assign[延迟]wire型变量=表达式; 数据流描述利用数据流描述可以很方便的描述一个加法器等，用符号就可以了，比如+ *等 组合逻辑的行为描述组合逻辑建模实例 比较器 译码器和编码器 时序逻辑电路时序逻辑建模概述时序逻辑电路指的是在verilog HDL所描述的电路中，包含一个或多个存储单元。这些存储单元可以是边沿触发的寄存器，或者是电平触发的锁存器。由于引入了存储单元，时序逻辑电路具有了“记忆”功能，可以记录当前时刻之前的输入激励情况及电路状态。 寄存器和锁存器设计 寄存器实例在always后面的敏感列表中加入边沿敏感的信号，即可设计出一个简单的寄存器。posedge是在时钟的上升沿触发并采集数据端口的值；negedge则在下降沿触发。 1234567891011module dff( input i_clk, input i_din, output reg o_dout);always@(posedge i_clk) //在always语句的敏感列表@()中加入边沿敏感的时钟信号i_clk o_dout &lt;= i_din;endmodule 锁存器的设计实例用verilog描述一个的锁存器，该锁存器在控制信号i_en为高电平时开启，为低电平时锁存器当前值 123456789101112module latch( input i_en, input i_din, output reg o_dout);always@(i_den or i_en) //敏感列表中没有边沿触发的信号 if(i_en) o_dout &lt;= i_din;endmodule 寄存器和锁存器的推断 寄存器的推断 寄存器是一种时序元件，用于存储数据，并且在时钟信号的上升沿或下降沿触发时更新数据。 寄存器在时钟边沿触发时，将其输入数据传递到输出，具有确定的时序行为。 在Verilog中，通常使用触发器（Flip-Flops）来实现寄存器。 123456789101112//举例说明module DFF ( input wire D, // 数据输入 input wire CLK, // 时钟信号 output wire Q // 数据输出);always @(posedge CLK) begin Q &lt;= D;endendmodule 锁存器的推断 锁存器是一种组合逻辑元件，它不需要时钟信号，而是根据输入信号的变化实时更新输出。 锁存器不是时序元件，通常应该避免在数字电路中使用锁存器，因为它们可能会导致不稳定的行为和时序问题。 锁存器可能会导致冒险条件，因此在设计中应该谨慎使用。 12345678910//举例说明module SRLatch ( input wire S, // 设置输入 input wire R, // 复位输入 output wire Q // 数据输出);assign Q = S &amp; ~R;endmodule 存储器的设计与建模 ROM建模ROM是只读存储器 1234567891011121314151617181920212223//变量z以数组的方式描述了一个ROM//由于使用了inital语句，因此该代码只能适用于仿真，不能综合module rom_sim( input [2:0] i_sel, output [3:0] o_dat); reg [3:0] rom [0:7]; //通过数组声明存储器变量 inital begin //利用inital语句为ROM赋值 rom[0] = 4'b1001; rom[1] = 4'b1011; rom[2] = 4'b0010; rom[3] = 4'b0011; rom[4] = 4'b1110; rom[5] = 4'b0000; rom[6] = 4'b0000; rom[7] = 4'b0000; end assign o_dat = rom[i_sel];endmodule RAM建模一个电平变化触发的16位宽RAM模型通常是基于时序逻辑的，使用触发器来存储数据。以下是一个简单的电平变化触发的16位宽RAM模型示例，使用2个16位触发器作为存储元件： 12345678910111213141516171819202122module LevelSensitiveRAM16 ( input wire [3:0] address, // 4位地址输入 input wire [15:0] data_in, // 16位数据输入 input wire write_enable, // 写使能信号 input wire read_enable, // 读使能信号 output wire [15:0] data_out // 16位数据输出);reg [15:0] memory [0:15]; // 16个16位触发器，模拟RAM的存储单元always @(posedge write_enable or posedge read_enable) begin if (write_enable) begin // 写操作：将输入数据写入存储器指定地址 memory[address] &lt;= data_in; end if (read_enable) begin // 读操作：从存储器指定地址读取数据 data_out &lt;= memory[address]; endendendmodule 同步有限状态机同步有限状态机（Synchronous Finite State Machine，SFSM）是一种在特定时钟信号下运行的状态机，其中状态的转换和输出的更新都与时钟信号同步。SFSM 包括状态寄存器、组合逻辑块以及时钟信号。 以下是一个简单的 2 状态同步有限状态机的示例，其状态转换和输出更新是同步的： 12345678910111213141516171819202122232425262728293031323334module SynchronousFSM ( input wire clk, // 时钟信号 input wire rst, // 复位信号 output wire [1:0] state, // 2位状态输出 output wire output // 输出信号);reg [1:0] current_state; // 当前状态寄存器always @(posedge clk or posedge rst) begin if (rst) begin // 复位操作 current_state &lt;= 2'b00; // 将状态初始化为00 end else begin // 状态转换逻辑 case (current_state) 2'b00: current_state &lt;= 2'b01; // 从00转换到01 2'b01: current_state &lt;= 2'b10; // 从01转换到10 2'b10: current_state &lt;= 2'b00; // 从10转换到00 endcase endendassign state = current_state; // 输出当前状态always @(posedge clk) begin // 输出逻辑 case (current_state) 2'b00: output &lt;= 1'b0; // 当前状态为00时输出0 default: output &lt;= 1'b1; // 其他状态时输出1 endcaseendendmodule 时序逻辑建模实例 计数器 串并/并串转换器 12345678910111213141516171819202122232425262728293031323334module p2s(clk,en,rsy,pin,sout)；input clk,en,rst;input [7:0] pin;output sout;output end; #并转串传输结束reg[2:0] cnt;reg[7:0] data;always@(posedge clk or posedge rst) if(rst) sout &lt;= 1'b0; cnt &lt;= 3'b0; end else if(en) begin cnt &lt;= cnt+1'b1; sout &lt;= data[0]; endalways@(posedge clk or posedge rst) if(rst) data &lt;= 8'b0; else if(cnt==3'b0) data &lt;= pin; else data &lt;= {1'b0,data[7:1]};always@(posedge clk or posedge rst) if(rst) end &lt;= 1'b0; else end &lt;= (cnt==3'b111);endmodule 时钟分频电路 练习题5.4 1234567891011121314151617181920module 8bit( input wire clk, input wire rst, input wire [7:0] data_in, output wire [7:0] data_out); reg [7:0] reg_data; always @(nesedge clk or posedge rst)begin if (rst) reg_data &lt;= 8'b0; else reg_data &lt;= date_in; end end assign data_out = reg_data;endmodule 5.6 123456789101112131415module 32_RAM(clk,wr,addr,rdata,wdata); input clk,wr; input [31:0] wdata; input [14:0] addr; output [31:0] rdata; reg [31:0] ram[32767:0] always@(posedge clk) if(wr) ramp[addr] &lt;= wdata; else assign rdata =ram [addr];endmodule 5.7 1234567891011121314module 32_RAM(clk,wr,addr,data); input clk,wr; inout [31:0] wdata; inout [14:0] addr; reg [31:0] ram[32767:0] always@(posedge clk) if(wr) ramp[addr] &lt;= wdata; else data ram[addr] assign rdata =ram [addr];endmodule 5.11 1234567891011121314151617181920212223242526272829module fsm(clk,rst_n,sel.hready,write,burst,resp_ok) input clk,rst_n,sel,hready,write,burst,resp_ok; parameter Reset=3'b000; parmeter Idle=3'b001; parmeter Addr=3'b010; parmeter Write=3'b011; parmeter Read=3'b100; parmeter BurstWrite=3'b101; parmeter BurstRead=3'b110; parmeter Resp=3'b111; reg [2:0] next_state.current_state; always@(posedge clk or negedge rst_n) if(!rst_n) current_state &lt;= Reset; else current_state &lt;= next_state; always@(rst_n or sel or hready or wirte orburst or resp_ok) case(current_state) Reset: if(rst_n) next_state =Idle; Idle: if(sel&amp;&amp;hready) next_state = Addr; Addr: if(write&amp;&amp;burst) next_state = Burstread; else if(!write&amp;&amp;burst) next_state = burstread; else if(!write&amp;&amp;burst) next_state = Read; else next_state = Write; ......endmodule 行为级仿真模型建模组合逻辑和时序逻辑建模可以通过门级描述、数据流描述或行为描述来实现，用数据流或行为级语法进行可综合的电路描述，被称为RTL描述，即寄存器传输级描述。而利用门级语法进行描述的，通常称为结构级描述或层次化描述。 概述verilog提供的时序控制语句主要有3种：延迟控制语句，事件控制语句和条件等待语句。 仿真时间和时序控制事件控制语句指利用语法@()进行描述，@后面的括号里包含需要的语句 仿真模型建模实例 时钟发生器 简单的仿真环境 从文件读取激励 输出结果监控当调用$monitor任务时，参数列表中指定的变量都将被仿真器控制。 总线功能模型总线功能模型(BFM)通常是某个总线主设备的接口电路模型SoC芯片指在单个芯片上集成一个完整的数字电路系统 各层次verilog HDL描述形式与电路建模基本的数字单路单元模块各抽象层次的verilog HDL描述形式verilog HDL的描述形式可概括分为：门级描述(或称层次化描述)：and nl(out, opa, opb);数据流描述：assign out=opa&amp;opb;行为描述： 123always@(opa or opb)begin out=opa&amp;opb;end 利用各层次描述进行组合逻辑建模数据流转换为行为描述的步骤 将数据流描述中连续赋值语句左边的变量定义为 reg 类型； 利用 always 模块描述组合逻辑，将连续赋值语句等号右边的所有信号都加到 always语句后面的变量敏感列表中，且所有信号都是电平敏感的； 在 always 模块中利用阻塞赋值语句对左边变量进行赋值，赋值语句等号右边的表达式与连续赋值语句右手边的表达相同。 利用各层次描述进行时序逻辑建模 利用各层次描述进行行为仿真逻辑建模 任务与函数任务语句说明语法定义： 1234task 任务名; 端口声明和变量定义； 一个或多个过程语句；endtask 任务的调用语法：任务名 (参数1, 参数2, 参数3, ...); $time 系统函数将返回当前仿真时间 任务和函数的联系和区别 函数不能包含时序控制语句，如@()、#10 等； 在函数中不能调用任务，而任务可以调用其他任务和函数； 函数必须包含至少一个端口； 函数必须返回一个值，而任务不能返回值。 $monitor任务$monitor任务可以用来监控并打印任何指定的变量或表达式 编译预处理编译指令实现的编程预处理功能 ‘define, ‘undef‘define指令用于定义文本替换；‘undef指令则是取消前面定义的宏 ‘ifdef, ‘else, ‘elsif, ‘endif, ‘ifndef工程师会根据某些条件选择性地编译某部分代码，同时选择性地忽略掉一些代码，而实现这样功能的编程指令就是条件编译指令。 verilog HDL设计与综合中的陷阱阻塞语句和非阻塞语句 阻塞语句阻塞语句用操作符号 = 进行连接，起基本语法格式为寄存器变量(reg) = 表达式/变量 阻塞语句的含义： 在多个阻塞语句顺序出现，出现的语句会完全阻塞后面的动作，直到前面的语句被执行结束，即执行的顺序性； 在赋值钱不能插入任何动作 非阻塞语句非阻塞语句用操作符号 &lt;= 进行连接，起基本语法格式为寄存器变量(reg) &lt;= 表达式/变量 规则 当描述时序逻辑时，用非阻塞语句； 当描述组合逻辑时，用阻塞语句； 当在一个always模块中同时描述组合逻辑和时序逻辑时用非阻塞语句； 在同一个always模块中不要混合使用阻塞和非阻塞语句。 锁存器的产生与危害无意识锁存器产生的主要原因有两个： 在设计组合逻辑中使用不完整的条件判断语句，即有if没有else，或是在设计组合逻辑中使用不完整的case语句； 设计中使用到了组合逻辑反馈等异步逻辑。 组合逻辑反馈规则： 当描述组合逻辑时，禁止使用组合逻辑反馈； 当需要描述反馈环路时，必须使用边沿触发。 复位电路设计问题与改进 同步复位电路同步复位的好处： 保证整个系统是一个完全同步的系统； 复位信号只在时钟的有效边沿处才能复位寄存器，在一定程度上，滤除了复位信号上的毛刺； 在某些设计中，复位信号由一系列条件产生，这时同步复位是一种有效的方法，因为同步复位能够滤除组合逻辑在时钟信号之间的毛刺； 同步复位的坏处： 同步复位需要时钟参与，复位信号有效期间如果没有工作时钟，则不能复位； 同步复位增加了组合逻辑的时延，降低了设计的速度。 异步复位电路异步复位的好处： 直接利用内部寄存器的硬复位引脚来复位寄存器； 复位信号不再参与到组合逻辑电路中，不影响逻辑的速度； 不需要时钟参与。 异步复位的坏处： 复位信号上的毛刺很容易导致系统的异常复位； 异步复位带来的最大问题就是异步，无论是寄存器复位还是复位的释放都是异步的。异步复位阶段一般没有问题，问题出在复位信号的释放阶段。如果复位信号正好在时钟沿附近释放，寄存器的输出将出现亚稳态。","link":"/2023/09/19/Verilog%E5%AD%A6%E4%B9%A0/"},{"title":"linux学习","text":"学习Linux，使用的书籍为《Linux轻松入门》(陈德全) linux概述linux = linux内核 + 程序库 + 用户程序接口 linux内核：提供OS(操作系统)的基本功能，如CPU调用、内存管理、进程管理； 模块：为了应对随时加入的代码，独立于内核外，模块化； 库(程序库)：提供函数和通用资源 Shell：硬件被内核管理，而内核又被保护，所以我们只能通过shell与内核沟通； 目录管理目录结构文件分为四类：可共享的、不可共享的、不变的、可变的 FHS规定了一个根目录(/),linux所有目录都会在根目录下 /bin：bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。 /boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev ：dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。 /etc：etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。 /lib：lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media：linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。 /opt：opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc：proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器： /root：该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin：s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。 /selinux：这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 /srv：该目录存放一些服务启动之后需要提取的数据。 /sys：这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。 /tmp：tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。 /usr：usr 是 unix system resources(unix 系统资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。 /usr/bin：系统用户使用的应用程序。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src：内核源代码默认的放置目录。 /var：var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 普通用户和管理员登录命令符不同[root@ubuntu~]中的root就是管理员，如果是普通用户则显示用户名字。 此外#表示管理员，$表示普通用户 关于linux命令，可以使用man命令查找 管理文件和目录 基本 pwd：显示目录当前所在位置 cd[目录]：这个路径可以使用绝对路径或相对路径来指定想要去的地方有几个特殊的符号需要额外的记住： ~ 当前用户的家目录 ~[用户名] 指定用户的家目录，中间没有空格 . 表示此层目录 ..或cd ../ 表示上一层目录 / 表示根目录 - 表示前一个工作目录 ls[选项][目录名称] ：列举该目录下的文件，通常只用ls，后面的需要再查吧 创建文件： mkdir[选项] 文件名：创建目录命令 touch[选项] 文件名：创建空白文件 删除文件： rmdir：删除空文件 rm[选项]文件名或目录名：rm命令不能直接删除一个文件，需要加上选项 -r：删除指定的文件和目录 -f：未经用户同意直接删除 -i：删除之前有提示 查看文件 cat[选项]文件名：这个命令可以从文件内容的第一行开始显示，不过不适用内容较长的文件； more文件名：可以一页一页显示文件的内容，只能向下查看文件内容(more和less都有具体的按键操作，可以百度查下) less文件名：可以向上查看文件内容 nl[选项]文件名：可以输出带有行号的文件内容 -b：指定行号指定的方式 -n：列出行号表示的方法 移动 mv[选项]源文件或目录 目标文件或目录：移动 -i：有相同文件时会问是否覆盖 -f：不问，直接覆盖 复制 cp[选项]源文件或目录 目标文件或目录：用于复制的 -a:保留所有信息并递归地复制； -r:原样复制源目录的层次结构； -d:复制时保留链接，这样不会失去链接文件； -p:保留文件属性(权限、时间)； -i:若存在相同文件，询问是否覆盖 确定文件类型 file[选项]文件名：查看文件类型","link":"/2024/04/02/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"},{"title":"hexo命令","text":"本篇用于记录hexo常见命令 hexo常用命令创建新文章使用以下命令后新文章将在博客目录下的/source/_posts/文件夹下 1$ hexo new [layout] &lt;title&gt; 举个例子，我今天想要创建一个hexo命令的文章，那我需要在git bash here中输入hexo new &quot;hexo命令&quot;即可创建新的文章，然后结合另一篇文章Markdown常见命令使用即可 发布文章以下简写代码和完整代码都可以使用 这是清理缓存： 1$ hexo clean 这是本地预览： 1$ hexo s (完整代码为$ hexo server) 这时会生成一个http://localhost:4000/网址，它相当于一个草稿，让你先看看要发布的文章有没有什么问题 $ hexo s -p 5000 1如果在运行hexo s后出现错误，无法访问等，可能是因为4000被占用了，所以我们可以修改至5000就可以预览我们修改的内容了 这是生成静态文件： 1$ hexo g (完整代码为$ hexo generate) 这是将本地文件上传github等git仓库上 1$ hexo d (完整代码为$hexo deploy) 我通常写完文章后会喜欢使用“一键三连”上传 123$ hexo clean$ hexo g$ hexo d 如果在上传过程中出现错误，先检查是不是代码打错了。如果不是代码问题，就是网络问题。这个全靠运气了，如果不行重启或者晚一点再上传。","link":"/2023/07/06/hexo%E5%91%BD%E4%BB%A4/"},{"title":"数字电路与verilog结合","text":"鄙人能力有限，对数电的理解还远远不够，甚至在基础知识上也有问题。于是写下此篇post，加深对数电的理解，并且结合verilog代码。在代码部分，我和同伴共同创作，会使用ChatGPT进行检测。注意：若代码有问题，请及时提出自己的疑问或是指出我的错误，相互学习共同进步，十分感谢！ 三种基本运算与门表达式与真值表 表达式$$ Y=A\\cdot B $$ 真值表 A B Y 0 0 0 0 1 0 1 0 0 1 1 1 verilog代码1234567module and_gate ( input a, input b, output c); assign c = a &amp; b;endmodule 或门表达式与真值表 表达式$$ Y=A + B $$ 真值表 A B Y 0 0 0 0 1 1 1 0 1 1 1 1 verilog代码1234567module or_gate ( input a, input b, output c); assign c = a | b;endmodule 非门表达式与真值表 表达式$$ Y=\\bar{A} $$ 真值表 A Y 0 1 1 0 verilog代码1234567module not_gate ( input a, output b); assign b = ~a; #assign b = ! a这样写也可以 endmodule 与非表达式与真值表 表达式$$ Y=\\overline{(A\\cdot B) } $$ 真值表 A B Y 0 0 1 0 1 1 1 0 1 1 1 0 verilog代码123456789101112module nand_gate ( input wire A, input wire B, output wire Y); wire and_out; and (and_out, A, B); not (Y, and_out);endmodule 或非表达式与真值表 表达式$$ Y=\\overline{(A + B) } $$ 真值表 A B Y 0 0 1 0 1 0 1 0 0 1 1 0 verilog代码 结构化结构 123456789101112module nor_gate ( input wire A, input wire B, output wire Y); wire or_out; or (or_out, A, B); not (Y, or_out);endmodule 数据流描述 12345678910module nor_gate ( input wire A, input wire B, output wire Y); assign Y = ~(A | B);endmodule 与或非表达式与真值表 表达式$$ Y=\\overline{(A\\cdot B+C\\cdot D)} $$ 真值表 A B C D Y 0 0 0 0 1 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 0 1 0 0 1 0 1 0 1 1 0 1 1 0 1 0 1 1 1 0 1 0 0 0 1 1 0 0 1 1 1 0 1 0 1 1 0 1 1 0 1 1 0 0 0 1 1 0 1 0 1 1 1 0 0 1 1 1 1 0 verilog代码 结构化结构 123456789101112module nand_gate ( input wire A, input wire B, output wire Y); wire and_out; and (and_out, A, B); not (Y, and_out);endmodule 数据流描述 12345678910module nand_gate ( input wire A, input wire B, output wire Y); // 直接用数据流描述与或非门的逻辑功能 assign Y = ~(A &amp; B);endmodule 异或表达式与真值表 表达式$$ Y = A\\oplus B$$ 真值表 A B Y 0 0 0 0 1 1 1 0 1 1 1 0 verilog代码 结构化结构 123456789101112131415module xor_gate ( input wire A, input wire B, output wire Y); wire and1, and2, notA, notB; not (notA, A); not (notB, B); and (and1, A, notB); and (and2, notA, B); or (Y, and1, and2);endmodule 数据流描述 12345678module xor_gate ( input wire A, input wire B, output wire Y); assign Y = A ^ B;endmodule 同或表达式与真值表 表达式$$ Y = A\\odot B $$ 真值表 A B Y 0 0 1 0 1 0 1 0 0 1 1 1 verilog代码 结构化结构 123456789101112module xnor_gate ( input wire A, input wire B, output wire Y); wire xor_out; xor (xor_out, A, B); not (Y, xor_out);endmodule 数据流描述 123456789module xnor_gate ( input wire A, input wire B, output wire Y); assign Y = ~(A ^ B);endmodule 组合逻辑电路编码器代码我举一个4-2编码器的代码： 123456789module bianma42( input [3:0] i_dec, output [1:0] o_dec) assign o_dec = (i_dec : 4'b0001) ? 2'b00: (i_dec = 4'b0010) ? 2'b01: (i_dec = 4'b0100) ? 2'b10: (i_dec = 4'b1000) ? 2'b11 : 2'bxx;endmodule 译码器加法器乘法器选择器比较器移位器时序逻辑寄存器在always结构化过语句后面增加边缘敏感信号(posedge和negedge)，就会变成一个简单的寄存器！ 简单寄存器寄存器的作用是让能够存储一组二值（0和1）代码，当边缘敏感信号触发时，就会收集收到的数据。以下是代码： 12345678module dff( input i_clk, input i_din, output reg o_dout); always@(posedge i_clk) o_dout &lt;= i_din;endmodule 同步有限状态机计数器计数器是一个非常简单的时序逻辑。计数器在系统时钟触发下进行计数，并在达到某一个值的时候输出对应的触发信号给其他的电路模块。 此处用一个4位宽的计数器做例子。一开始的初始值为0（verilog代码中可写作4’b0000），这时候我们启动时钟，每上升（或下降）一次就敲一下计数器，计数器就会记仇并在他的小本子上记录你欺负他的次数。由于是4位宽，所以他的忍耐上线是15次（verilog代码4’b1111）。当你达到他忍耐的上线时，他就会去告状并且发出一个忍无可忍的信号o_full，等他火气消了初始值又回变成0。计数器还包含了一个使能信号，当使能信号无效时，计数器暂停计数。 代码可以这么写： 12345678910111213141516module counter_4( input i_clk, input i_rst, input i_en, output reg [3:0] o_cnt, output o_full) always@(posedge i_clk or posedge i_rst)begin if(i_rst) o_cnt &lt;= 4'b0000; else if(i_en) o_cnt &lt;= o_cnt + 4'b0001; end assign o_full = (o_cnt == 4'b1111);endmodule 时钟分频器时钟分频器的作用是将高频率的时钟转换为低频率的时钟，如果你看过这个视频”计数器“更能够理解分频。 时钟分频计数器可以分为两类，一类是偶数倍分频，如视频所述的那样用计数器就可以实现，且分频后时钟的占空比可以达到50%；另一类则是奇数倍分频，是不能达到50%的。 如果你硬是要挑战难度，想用奇数倍分频达到50%，则需要同时利用输入时钟的上、下沿进行计数，产生两个奇数分频器，然后做异或运算就可以得到 偶数倍分频器设计一个偶数倍时钟分频器，该电路将输入时钟进行分频，产生一个相位与源时钟相同、周期为8的信时钟。代码如下： 123456789101112131415161718192021module even_freq_div( input i_clk, input i_rst_n, output reg o_clk); reg [2:0] cnt; // 3位计数器，能计数到7 always @(posedge i_clk or negedge i_rst_n) if (!i_rst_n) cnt &lt;= 3'b000; else if (cnt == 3'b111) cnt &lt;= 3'b000; else cnt &lt;= cnt + 1; always @(posedge i_clk or negedge i_rst_n) if (!i_rst_n) o_clk &lt;= 1'b0; else if (cnt == 3'b111) o_clk &lt;= ~o_clk;endmodule 奇数倍分频器设计一个占空比不为50%的奇数倍分频器，该电路的输出时钟周期为输入时钟的7倍，占空比为4/7。代码如下: 123456789101112131415161718192021222324252627282930313233module odd_divider_7_4( input clk, input rst, output reg clk_out ); reg [2:0] counter; always @(posedge clk or posedge rst) begin if (rst) begin counter &lt;= 3'd0; end else begin if (counter == 3'd6) begin counter &lt;= 3'd0; // 计数器到达7时复位 end else begin counter &lt;= counter + 3'd1; end end end always @(posedge clk or posedge rst) begin if (rst) begin clk_out &lt;= 1'b0; end else begin if (counter &lt; 3'd4) begin clk_out &lt;= 1'b1; // 在0到3时输出高电平 end else begin clk_out &lt;= 1'b0; // 在4到6时输出低电平 end end endendmodule","link":"/2024/08/08/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8Everilog%E7%BB%93%E5%90%88/"},{"title":"SystemVerilog学习","text":"学习systemverilog语言 第I章 验证导论基本测试平台的功能测试平台的用途在于确定待测设计的正确性，包含以下步骤:1.产生激励2.把激励施加到DUT上3.捕捉响应4.检验正确性5.对照整个验证目标测算进展情况 第II章 数据类型内建数据类型两种基本类型：变量和线网，各自都可以有四种取值：1,0,Z,X 1.逻辑(logic)类型SystemVerilog对经典的reg数据类型进行改进，使得它除了作为一个变量以外，还可以被连续赋值、门单元和模块所驱动，这种改进的数据类型被称为logic。任何使用线网的地方均可以使用logic，但要求logic不能有多个结构性的驱动 12345678910111213//logic类型使用实例module logic(input logic); parameter CYCLE=20; logic q,q_1,d,clk,rst_1; inital begin clk=0; //过程赋值 forever # (CYCLE/2) clk=~clk; end assign rst_1=~rst_h; //连续赋值 not n1(q_1,q); //q_1被门驱动 my_dff d1(q,d,clk,rst_1); //q被模块驱动endmodule 2.双状态数据类型最简单的双状态数据类型是bit，无符号。另外四种带符号的双状态数据类型是byte,shourtint,int和longint。 定宽数组初始化和声明必须声明上下界int lo_hi[0:15]; //16个整数[0]...[15] 声明并使用多维数组int array[0:7][0:3]; //完整的声明 常量数组常量数组：一个单引号加大括号来初始化数组int ascend[4]='{0,1,2,3}; //对4个元素进行初始化 for 和 foreach i被声明为for循环内的局部变量 在foreach循环中，只需要指定数组名并在其后面的方括号中给出索引变量，SV就会自动遍历数组中的元素。 复制和比较 比较仅限于等于或比较不等于 操作符?:一个袖珍的if语句 使用位下标和数组上标123456inital begin bit [31:0] src[5] = '{5{5}}; $display (src[0],, // 'b101或'd5 src[0][0],, // 'b1 src[0][2:1]); // 'b10end 合并数组数组大小定义的格式必须是[msb:lsb]，而不是[size]，就是个数 动态数组动态数组在声明时使用空的下标[ ]. 必须调用new[]操作符来分配。 队列可以在一个队列中的任意地方增加或删除元素，队列的声明时使用带有美元符号的下标:[$]。队列元素的编号从0到$ 可以用字下标串联来替代方法，如果把$ 放在范围表达式的左边，那么$ 将代表最小值；如果把$ 放在范围表达式的右边，那么$ 将代表最大值。 关联数组创建大容量数组可以用动态数组，创建超大容量用关联数组 链表数组的方法","link":"/2023/12/16/systemverilog%E5%AD%A6%E4%B9%A0/"},{"title":"半导体制造","text":"半导体制程是被用于制造芯片，一种日常使用的电气和电子器件中集成电路的处理工艺。它是一系列照相和化学处理步骤，在其中电子电路逐渐形成在使用纯半导体材料制作的晶片上。硅是今天最常用的半导体材料，其他还有各种复合半导体材料。从一开始晶圆加工，到芯片封装测试，直到出货，通常需要6到8周，并且是在晶圆厂内完成。 笔记这是我专业课最后期末复习的笔记，内容不是很多，都是知识点，也不是很难，只需要记住就可以了。如果在预览过程中发现有知识性错误请及时联系我修改！ 若无法显示PDF，可以点击该链接下载半导体制造","link":"/2023/09/16/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%88%B6%E9%80%A0/"},{"title":"人脸识别实战","text":"使用Python进行人脸识别 人脸图片数据收集Olivetti Faces人脸数据集我以纽约大学提供的一个非常小的人脸数据集举例，每人的人脸图片为10张，清晰度还算不错，且图片为经过剪裁和对齐的灰度人脸图片，下载网址 想要收集数据，我们首先要做的就是对每个人的人脸图片进行切分。代码实例如下： 12345678910111213import cv2data = cv2.imread(&quot;olivettifaces.jpg&quot;)#转换为灰度图像data = cv2.cvtColor(data, cv2.COLOR_BRG2GRAY)#将人脸图片提取为{label:list}形式faces = {}label = 0count = 1pic_list = []for row in range(20): for column in range(20): LFW人脸数据集由马萨诸塞大学提供，LFW人脸数据集 YouTube Faces人脸数据集这个一般是用来做人脸对比的，该网站包含1595个不同的人，来自于3425个在YouTube上下载的视频，网址地址：YouTube Faces 使用OpenCV的人脸检测OpenCV的安装在Python中直接用pip下载 pip install opencv-python 如果是在anaconda环境中安装OpenCV，可以通过以下方法： conda install opencv OpenCV的检测#查看引入OpenCV库时会不会报错 import cv2 #查看安装版本 cv2.__version__ Haar级联分类器在此之前需要先下载两个训练好的xml文件，可以在GitHub中下载将下载的文件放到和运行脚本同一个文件就可以了。 如果你没有放对xml，就会出现以下错误提示：errror:(-215)!...... 获得训练好的模型之后，就可以根据这个模型进行人脸识别了，完整代码如下： import cv2 #创建人脸检测级联分类器对象实例 face_cascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml') #或采用lbp特征进行检测 #face_cascade = cv2.CascadeClassifier('lbpcascade_frontalface.xml') #创建人眼检测级联分类的实例 eye_cascade = cv2.CascadeClassifier('haarcascade_eye.xml') #载入图片 img = cv2.imread('lena.jpg') #图片颜色意义不大，灰度化处理即可 gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #调用级联分类器进行多尺度检测 faces = face_cascade.detectMultiScale(gray, 1.3, 5) #遍历检测到的结果 for (x,y,w,h) in faces: #检测矩形框，颜色值的顺序为BGR，即矩阵的颜色为蓝色 cv2.rectangle(img,(x,y),(x+w,y+h),(255,0,0),2) #roi即region of interest, 意思是感兴趣的领域 roi_gray = gray[y:y+h, x:x+w] roi_color = img[y:y+h, x:x+w] #在检测到的人脸区域内检测眼睛 eyes = eye_cascade.detectMultiScale(roi_gray) for (ex,ey,ew,eh) in eyes: cv2.rectangle(roi_color,(ex,ey),(ex+ew,ey+eh),(0,255,0),2) #写出图片 cv2.imwrite('detected_face.jpg',img) 使用Dlib的人脸检测Dlib自带了基于Hog特征的人脸检测器，同时在较新版本的Dlib 中，也自带了基于最大边界对象检测器 (Maximum-Margin Object Detector，MMOD)的人脸检测方法。 基于Hog-SVM的人脸检测下面示范一下使用 Dlib 自带的 Hog-SVM 人脸检测器的使用方法: import dlib import cv2 img = cv2 .imread('lena.jpg') # 加载检测模型 hog_face_detector = dlib.get_frontal_face_detector() faceRects = hog_face_detector(img，0) for faceRect in faceRects: xl = faceRect.left () y1 = faceRect.top() x2 = faceRect.right () y2 = faceRect.bottom() 上述代码需要下载Dlib训练好的检测模型，[官方地址](htp://dlib. net/files/data/dlib_face_detector_training_data. tar. gz)","link":"/2023/03/19/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"},{"title":"ubuntu学习记录","text":"记录Ubuntu的学习 权限开放sudo -s 共享文件夹位置cd /lscd mntlsvmhgfs-fuse /mnt/hgfs进去文件就可以了 VMware的Ubuntu中通过共享文件夹向win 在 Ubuntu 中挂载共享文件夹sudo mkdir /mnt/hgfssudo vmhgfs-fuse .host:/共享文件夹名称 /mnt/hgfs -o allow_other 复制文件到共享文件夹cp /path/to/your/file.txt /mnt/hgfs/ win传文件到Ubuntu 在Ubuntu中挂载共享文件夹sudo mkdir /mnt/hgfssudo vmhgfs-fuse .host:/共享文件夹名称 /mnt/hgfs -o allow_other 传输文件ls /mnt/hgfs 从共享文件夹中复制文件到Ubuntu系统cp /mnt/hgfs/文件名 /home/yourusername/目标目录/","link":"/2024/08/08/ubuntu%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"旅游-澳门 II","text":"写这篇post的时候已经是2023.10.8了，本来计划在国庆假期内写完，还是拖到了现在才想起来，接下来就要我凭印象记录了。这次是受高中同学的请求，带其去澳门看看，正好假期有空，便欣然答应。这是我第二次去澳门，上次一人独行，初次领略纸醉金迷和高雅浪漫，可惜时间有限加之体力不足，未见夜晚的澳门的灯红酒绿，颇有些遗憾。此次前往，也算了却我一个小小的心愿。澳门是一座美丽的城市，拥挤与繁华，富裕与友善，是我对这座小城市的印象。这座不及浦东机场面积的小城，竟甚至能在2019年产生世界第二的人均GDP。接下来，我将回忆本次去澳门的所见所闻与君分享。 旅行 过境准备我们乘坐C7611与9:20到达珠海站，之后前往青茂口岸，路途换了20mop坐公车。青茂口岸在2021年9月8日才正式投入使用，这里人少，快捷，凉快，吸取上次在拱北口岸大排队的教训，我们很快通过了海关，正式踏入澳门境内。 澳门半岛从口岸坐公车前往澳门亚美打利庇卢大马路市政署和议事亭前地并拍照留念 之后前往大三巴及周边附近拍照留念 新葡京及附近娱乐场拍照留念 在梳打冰室吃午餐 吃饱喝足之后前往澳门冼星海大马路澳门回归贺礼陈列馆 路氹伦敦人、巴黎人、威尼斯人逛逛 晚饭吃M记，吃太快没拍 夜晚的澳门 返航结束旅程，乘坐发财车返回口岸 个人感想很喜欢澳门，这里民风淳朴，风景怡人，物价吓人。未满21岁还不让我进赌场，不能一睹美女荷官芳容，可惜可惜。下次再来吧，澳门活动也多，可以来一场说走就走的旅行。","link":"/2023/09/29/%E6%97%85%E6%B8%B8-%E6%BE%B3%E9%97%A8/"},{"title":"旅游-外伶仃岛","text":"自国庆假期以后，我便陷入了上课和学习的纠缠，生活中再也不如从前那般恣意。随着身心疲惫渐显，渴望一次宽慰身心、回归自然之旅渐生。因此，我迅速检查了周末的天气情况，立即预订了船票，最终期盼已久的日子终于到来，我难掩内心的喜悦。如今，结束了这次旅程，我迫不及待地开始写这篇文章。 外伶仃岛一日游装备列表 穿着：登山帽、墨镜、短袖、运动长裤、运动鞋 军粮：三明治、布丁、一包吐司、巧克力、550ml水 拍摄：手机支架、长焦倍镜 其他：清凉油、身份证、交通卡、充电宝 徒步路线早上9：40从香洲港码头出发，于11：00抵达外伶仃岛。环岛旅行的交通方式有两种：乘坐观光车和步行前往。为了全身心融入这座美丽的小岛，我选择了徒步旅行。下了船，匆匆拍了两张港口的照片给朋友们分享后，便立即出发。徒步路线大致如下： 矿石湖今日的外伶仃岛矿石湖，曾经矿石开挖地，因为人工开挖自然形成的矿坑，遗留的开挖痕迹和大小碎石，足以想象曾经的忙碌与辉煌。 最美公路外伶仃岛本就是一座被遗世独立的小岛，远离珠海市区，靠近香港，我徒步抵达时恰为正午，人烟稀少，只有远处鸣笛声声的货轮、呼啸长空的客机以及自由翱翔的鸟类陪伴，好生惬意。这条被誉为“最美公路”的蜿蜒小道是通往山顶的必经之路，也是最佳欣赏海景的不二之路。 走在这条路上，是我人生最安静的时光。我不需要思考过去和未来，也不必担心现在，只是单纯的享受阳光和大海，很难用语言或是音乐来描述我当时的意境。我坐在高处，阳光毫不吝啬的洒向每片角落，望向远方海天一色的美景，波光粼粼的海面驶过满载的货轮，聆听汩汩的海浪声，老鹰在空中肆意盘旋。我无法停止对蓝天与大海的赞美，我生于斯，也希望死于斯，铭于斯，其魂气无不之也。他总是这样，海纳百川，包容我于所有不完美，接纳我于所有无痛呻吟，即使我没有带来鲜花与热血。在此，我可以同最原始的自己交流，我们不再探讨未来的经济、职业与社交，也不再欣赏音乐与哲学，只是静静地融入这里和倾听心脏平稳的跳动。 独爱海景我独爱海景，世间任何景色都难比于他。他给予我宁静，让我甘愿表露真我；他给予我恐惧，让我理智直面暗潮汹涌；他给予我方向，让我以自己的意志抵达未知。在无数个夜晚，感受到自己浸泡在海水中，随着洋流飘荡，与鱼群为友，与浪花为帆，穿越七大洲八大洋，没有目的，也是所有的目的地。我独爱海景，我无法停止赞美你，请祝福远行的游子早日追寻到她的自由与爱，赞美大海！","link":"/2023/11/04/%E6%97%85%E6%B8%B8-%E5%A4%96%E4%BC%B6%E4%BB%83%E5%B2%9B/"},{"title":"旅游-新加坡","text":"旅游时间：2024.8.25-2024.8.27(香港-新加坡)关于新加坡，我从它还没免签的时候就一直期待去旅游，直到这次研习营结束之后有时间可以去了，于8.10买往返票。这是我第一次出国，当然，还是一个人去的。本来这次我不打算告诉妈妈我要出国旅游了，直到去新加坡的前一天，妈妈说让我回家玩一个星期再开学，我就只好坦白了我自己的行程。以为会被骂一顿，没想到妈妈非常开心和支持，并赞助了我500块钱，让我注意安全，并表示怎么不带她一起出去玩，哈哈。非常感谢我的妈妈许女士对我的爱，我也永远爱你。 角色栏 穿着：短袖、短裤、长外套、运动裤、运动鞋 移动方式：步行、地铁、公交、飞机 证件：护照、身份证、visa银行卡、过关小票、机票、行程单 花费：2000+ 其他：充电宝、数据线、转换头 注意事项 新加坡不能吃口香糖 闯红灯和不走斑马线被抓到要罚款 公交地铁上不能喝水吃东西，要罚款 扶梯靠左，右边让给赶路的人 有鸟欺负你不能还手，否则罚款 从香港机场出发2024.8.25我急匆匆从学校到港珠澳大桥口岸，路上堵车+司机走错了路，让我一度差点迟到，不过幸运的是赶上了。我所乘坐的是直达机场的大巴，花费220人民币(120港币免税，在机场可退)，包含了托运行李(本次行程我没有需要托运的行李)和值机，非常的方便，我认为这个车票是值得的。在香港机场时，只有值机的姐姐不会说普通话很冷淡的完成了服务，以及borading time时签字的姐姐对除我以外的外国人/港人说thank u(我对她说了thank u以回敬她的不礼貌)，其他人都非常好，哪怕我说普通话也会非常热心的帮助我，解答我的问题。 酷航之旅在出发前我在网上看到说酷航准点率很低，有被取消的风险，空调也非常冷，会把人冻死，服务也是没有的，甚至很差。为此我买了一份保险，以防机票被取消。不过让我惊讶地是，空调和服务没有网络上说的那么差，我还是非常满意的。因为是红眼航班，为了我之后的精力，我选择上机就睡。 Jewel(抵达)经过4个小时的行程，于凌晨1点多抵达樟宜机场。完成过海关之后，我就到了Jewel，靠近瀑布，空气中弥漫着潮湿和清新的味道，在黑暗处有很多就地而睡的人，为了不打扰他们我拍完照便快速离开，见证了凌晨的Jewel，与我回来时看到的情景完全不同。 第一顿早餐(旺)本来第一天要去亚坤的，找流量卡花了很多时间，就在机场随便找了一家吃。前台是一位马来的姐姐，我和她用英文对话，由于我不知道那个菜品怎么念，我就说了NO.1set，姐姐也明白我的意思，问了一些问题，但是我听不懂就用菜单给我解释了，大概的意思是：这个套餐里面有一个咖椰面包+2个鸡蛋+饮品，问我想要什么饮品。我说“kopi”(马来语中咖啡的意思)，姐姐给了我很高的情绪价值“yes! kopi!”不过这家不好吃，可能是我酱油放多了鸡蛋好咸。 新加坡南洋理工大学(NTU)到新加坡的第一站就是NTU，很多山路，非常不好走，导航找不到方向，凭直觉走。校园很大，建筑很矮，有免费的校车可以坐。在NTU我参观了各大工程学院，不太好意思去看他们的教室，怕打扰教授和同学上课。 参观了著名的自习室小笼包The Hive，里面真的很漂亮。 离开之前我去打卡了四语牌，可惜当时身边没有人，没有与校排合影。 西海岸公园避开旅游圣地圣淘沙，来海边走走可以选择西海岸公园。这里人很少，有地方坐，海景很漂亮，有个港口，货船私船或是停靠岸边，或是潇洒飘荡。 我在这里吃了新加坡的麦当劳，说实话，味道一般，牛肉上面的酱有种甜甜的咖喱感，不过我当时很饿，还是吃完了。薯饼没有薯条好吃，可乐全世界都一个样。 怡丰城来这个商场的目的就是为了短暂的休息和看圣淘沙，这次我的行程中没有安排圣淘沙的游玩项目，所以只是远远的看了它一眼就回酒店休息了一会儿。 鱼尾狮公园著名景点，不多赘述。 这里和香港相似，新加坡河的两侧分别是金沙酒店和鱼尾狮，而鱼尾狮的附近全是金融的高楼大厦，看着十分壮观，和香港的维多利亚港很像。 这里无论白天黑夜我都打卡了，各有各的风味。 牛水车这是第二天的行程了，那天恰巧下大雨了。我在这里拍了新加坡佛牙寺龙华院和马里安曼庙，并且在这里吃了亚坤(太饿了忘记拍照了)，总算是圆了这个心愿。新加坡佛牙寺除了供奉释迦牟尼的遗牙佛牙舍利给佛教信众参观，亦为公众提供社会服务。 马里安曼庙（Sri Mariamman Temple）是新加坡最古老的兴都教（印度教）寺庙，建筑风格为德拉威风格。其位置处于市中心的桥南路244号，主要为这个城市国家的信奉兴都教的南印度泰米尔裔新加坡人提供服务。由于建筑和历史意义，马里安曼庙已经列入国家级名胜古迹，并且是一个主要的旅游景点。马里安曼庙由新加坡社会发展、青年与体育部下辖的兴都教捐赠委员会负责管理。 Jewel和樟宜机场(返程)白天的樟宜机场和Jewel与晚上大不相同，可以逛的东西更多，很出片，超级漂亮，我逛了很久。 我的人生照片XD —END—","link":"/2024/08/29/%E6%97%85%E6%B8%B8-%E6%96%B0%E5%8A%A0%E5%9D%A1/"},{"title":"旅游-香港","text":"2023.12.11-2023.12.12 独行香港香港有着“东方之珠”的美称，这个名字我以前也只在书中、电视里和母亲的口中听闻，它的繁华和发展早就在深入我心。基于2019年事件和网络上对香港的负面评价，作为一名非粤语母语者，对于香港多少带有恐惧情绪，万般纠结后还是决定亲自去看看这座城市。恰逢考完试有空闲时间，收拾好行李买好票就出发前往独自香港，开启了我的两天一夜香港之旅！ 注意事项 提前准备好八达通或者支付宝的香港地铁卡(我强烈建议用八达通) 旅行时间短可在网上买境外流量包，时间长去便利店买33$的流量卡(50G+1000分钟电话，有效期1年) 换一些零钱，有的店只收现金 上下扶梯靠右站，上下楼靠左走 不要在公众场合抽烟 不要喂鸟类 过海关不要带违禁品，注意携带烟酒数量 角色栏 穿着：短袖、短裤、长外套、运动裤、运动鞋 移动方式：步行、地铁、公交、渡轮 证件：港澳通行证、身份证、交通卡、银行卡、过关小票、金巴小票 花费：1000+ 其他：充电宝、数据线、转换头 Day1从学校出发，要前往港珠澳大桥珠海关口，最快的方式是乘坐高铁抵达拱北口岸后打车。由于C7611车次临时停运，我只能乘坐C7617，加上打车的时间(直接坐出租车花了23，如果用打车软件会更便宜)近11点才抵达珠海关口。 海关内禁止拍照，我描述一下。从“往香港”的入口随指示牌扫描通行证，按指纹，然后往前走，根据指示票前往穿梭巴士等候站，在大厅记得取票(一定要取票，检票不能用电子的，要扫实体票上的二维码)。跟随人流排队上车，很快就能上车。中午11点左右出发，坐左侧无太阳可看珠海、深圳、香港的城景和反光的大海；右侧有太阳但是看到的海景比左边好看，靠近香港机场可以见到蓝绿的海和缆车。 达到港珠澳大桥香港口岸后，随着人流过海关，下来在门口看到便利店可以在里面购买流量卡。出去之后可以选择搭乘巴士，巴士的价格和地点上面都有写。省钱小技巧：乘坐B5去欣澳站搭乘地铁前往想去的地方会便宜一些。若使用八达通，拍一下就可以上车了；使用支付宝则需要先切换左上角的地点至“中国香港”，后点击出行扫描二维码即可。到达欣澳后，我坐地铁去了深水埗吃饭，出地铁站走几步就看到了一家网红店“新香園 (堅記)” ，那时店里人挺多。一进门老板就热情的用普通话问我几位，我说1位后将我带进里面与两个老太太搭桌，拿着笔和纸问我吃什么。还好提前做了攻略，很快说出“冻奶茶和蛋牛治”，价钱小票和奶茶几乎同时放在我的桌子上，一个来回的功夫蛋牛治也好了，我拍了一张照后就狼吞虎咽的吃了起来。吃完拿着价钱小票去前台，收钱的老板不会讲普通话。“老細，AliPay————41蚊OK咗”，这是我在香港第一句粤语。 吃饱喝足在深水埗逛逛，又返回地铁站前往旺角站，去看看那些耳熟能详的站台和真实的香港。走在彌敦道上，来往的人络绎不绝，各种肤色的人穿梭在这条路上。大家都急急忙忙的奔向各自的目的地。汽车在中间车道上快速行驶着，双层的巴士来来往往，红色复古的出租车是香港的特色。道路两侧有着高耸入云的破旧大厦，有的是住宅，有的是办公楼。有时我会看到这些大厦的入口，银色的防盗门，里面漆黑一片，偶尔还有开门的大爷老态龙钟的坐着，与门外的繁华形成了强烈的反差。路上的人也走的很快，旅客、本地人都是如此，伴随着人声、车流声、信号灯机械的提示声，在这些高楼大厦下更有了压迫感。 走到佐敦地铁站不远处，在彌敦道和柯士甸道交叉路口，我灵光一现想去历史博物馆看看。沿柯士甸道上走，这里远离了大部分的人群，走路也稍微变慢了些，鸽子扑棱着翅膀飞向路灯，四处观察着这座魔幻的城市。走到漆咸道南的十字路口，我惊讶的发现了香港理工大学，不过没有进去参观，只是远远的拍了张照就前往旁边的香港历史博物馆了。 博物馆没意思，可能是我没找对 之后我又重新回到彌敦道，只为了打卡那座大厦————“重庆大厦” 继续往前走，我去了李小龙铜像，很多外国人都在铜像前摆着与雕像一致的动作合影留恋。沿着星光大道一路观赏着维多利亚港的美景，那时正好是太阳落山时间，夕阳的余辉洒在这片寸土寸金的大地上显得更加的高雅。 路过K11时，外面摆放着Dior的圣诞树，浑身上下都释放着昂贵的气息，引的人们前去打卡拍照，合影留念。 本来想去香港岛吃晚饭的，肚子实在太饿了，但是周边又没有什么好吃的，没办法，看到了麦当劳…谁来香港吃国际连锁快餐啊喂！我靠还真的好贵，而且味道没有特别的。这里有个小插曲，有个1.9m的白男似乎想续杯咖啡，前台的那个姐姐仰着头，义正言辞的说“NO”，似乎还有点生气，我有点害怕。巧的是，下一个取餐的是我，我说了句“雷猴”把小票递给她(我不会念数字)，拿着我的餐就跑，不敢有太多的接触，社恐本人了。 吃完饭外面也天黑了，终于可以看到维港的夜景了，为了这个夜景我才选择留在香港一晚。真的非常漂亮，比我2010年第一次去上海时还要震撼。坐在天星轮渡上，我甚至忘记了多拍几张相，而是静静的欣赏这座城市，非常喜欢。 乘坐渡轮到达中环码头，就可以看见香港摩天轮，买票加上车排队共花了近40分钟，20蚊上去转三圈。在摩天轮上看香港的夜景真的很美，也不贵，还能听旁边两个老外讲英语笑话。 结束了Day1中计划的最后一个部分，我就要前往酒店了。决定步行前往，切身感受下香港岛的高级打工地，这里的人西装革履总是在打电话，神情严肃，走路飞快，但是人不多。在这里总是有种窒息感和压力，偶尔几天我觉得还挺舒服的，时间久了可能就…快靠近酒店时我还迷路了，Google map和高德都不准，没办法，我只能根据店名来判断，地图上的大厦名我根本找不到，好在最后还是找到了酒店。前台的小哥很好，我说普通话也很耐心的帮我办理手续，并且免费给我升级了房型。晚上10点半肚子饿了，跑到楼下711买吃的，附近有几家酒吧，不过不吵也不会觉得不安全。一个人住酒店莫名有些害怕，开了一晚上的灯睡觉，休息的还算不错。Day1就在睡梦中结束了。 Day2早上8点多才起床，收拾好东西下楼check out，前往附近一家很出名的车仔面吃早餐。这家店“车仔面之家”已经开了60多年了，本地人也很喜欢吃，他家的特点是“立食”，因为店小只能站着吃，而且只收现金。里面的阿婆不太听得懂普通话，我的“幼面”和“油面”不太听得清，很耐心给我指着哪个面。点了配料之后在纸上给我写“35$”，我点的是“小份幼面+鱼蛋+鱿鱼”，他家的鱿鱼和猪大肠很出名。出餐也很快，接过面放在桌子上吃了几口我就开始找钱，正好口袋里有个5$的硬币。把钱拿过去时阿婆不在，只有个煮面的靓仔，看着有点凶。我鼓足勇气说“雷猴”他马上微笑过来，看到我把钱放在柜台上说“唔该”，我又回去吃面了，真的好好吃啊。之后来了一个东南亚男人，那个阿婆英语说的也好好啊，那个男人的咖喱味英语我都有点听不懂。 吃饱喝足来到下个目的地，也是我这次来香港的目的之一————办银行卡。我坐地铁前往汇丰银行北角分行，走过去的路上我不敢放慢脚步，生怕走慢了在银行前面犹豫而败北。进入银行，很庆幸里面没什么人，我找前台的姐姐问了这里可不可以开户，姐姐很耐心让我取个号等待。一分钟不到那个姐姐就领着我站在大堂的柜台上办理了。简单的问了我为什么来香港办理银行卡，我答了海淘和投资，姐姐没说什么，让我拿通行证、身份证、过关小票给她，填写信息就好，忙前忙后的，我就负责手机注册了。问了我现在有没有投资，我说有，基金，拿给姐姐看，不知道她看到我的白酒亏6个点是什么心情。旁边另外个姐姐过来问她“佢點解開卡？”“海淘”，以为我听不懂哈哈哈哈。当场下卡，开完就跑。 吃完去太平山，坐的小巴，想体验一下“亡命小巴”的感觉，亡命小巴，现在出发！那个山是真的高，转了好久才到 拍完下山去堅尼地城，本来要去熟食区买的，不会点餐，又跑出来了，去其他店看，不是人多就是好贵，之后去了大家樂，虽然这个也是连锁快餐，不过还是很有香港味道的 吃饱了就去香港大学了，买了纪念品HKU小熊。另外港大也真的很漂亮，虽然有点小，但是里面的学生给我一种精神气让我莫名有点畏惧，可能是社恐怕被同龄人问路吧hhh。 之后的时间我在港大坐着发呆，下午4点多返回九龙，去找汇丰的ATM机试图改卡的密码，失败，回去了。旅途结束了。","link":"/2023/12/13/%E6%97%85%E6%B8%B8-%E9%A6%99%E6%B8%AF/"},{"title":"论幸福——斯多葛主义","text":"你，幸福吗？周日的图书馆，靠窗的角落里，手里那本关于斯多葛主义哲学的书正在问我：你，幸福吗？ 于是我抬头看向窗外被风吹得摇摆不定的树枝，马路上呼啸路过的汽车，图书馆内稀稀疏疏的声音。适宜的温度，无忧无虑的当下。我想，至少现在，我是幸福的。 在毕业论文初稿截止的前一个星期的周日，一点也不担心论文能不能写完，写的是否糟糕；周一要去上班，要面对导师的质疑，重复而无用的工作是否对我的职业发展无用，现在也不感到焦虑；还有我的精神状态，不用想躯体化是否会突然吞噬我的身体，不用想我的记性变差是不是因为病理性的原因，不用担心焦虑和抑郁是否会在深夜里掐住我的喉咙、抨击我的胸口。哦天呐，此刻我真的很幸福。它不是令人兴奋的手舞足蹈乐观幸福，而是宁静安心的幸福。 这并不意味着我放弃了所有的感情，放弃了警惕。而是我学习到了斯多葛主义的核心——人应区分自己所能掌握和无法掌握的事情。关于我的论文，起初我也是非常焦虑不知道该怎么完成，后来我把他分成了很多部分，每天写一点，这周应该做到哪一步，下周的任务是什么。很高兴，因为我将难度分散成很多份小任务，困难就迎刃而解了，很有成就感。通过这件小事我分析道：无法掌握的是我未来是否能写完这篇论文，是否能写好这篇论文；能掌握的是为了解决这个问题，我将难题分解成我能做到的事情，每一个任务我都做的很好，按时完成了。我走出了第一步，确定了一个大方向之后就往后走吧，剩下的，顺其自然——这是斯多葛主义的第二核心，我又运用到了。 斯多葛主义是研究幸福的哲学，也并非意味着我们什么都不做就是幸福的，回到它的第二核心顺其自然。所谓自然发展是符合物理学和逻辑学的理性，从能量守恒的角度看：幸福和不幸，欢乐与痛苦这些对立的概念是共存的，为了幸福我们同样需要付出代价作为等价交换。 正如马可·奥勒留说：“生活的艺术与其说是舞者的舞蹈，更像是摔跤手的搏击”。现在把目光望向生活，它并不是完美幸福的。有原生家庭的烦恼，学业上的烦恼，就业升学的烦恼，职场上的烦恼。我们的媒体新闻明天都在播放着负能量的东西，每个人都怨气冲天，想着我为什么生来不是富二代，这样我就是幸福的了。我们正在被这样的负面情绪影响，竟在不经意间成为一个负能量的人。这，其实是一场搏击训练！ 面对这样的情况，就要运用到斯多葛主义的第三核心——热爱自然与人类。在面对负能量这场训练场上，我们被现实一拳砸在脸上，它在嘲笑我们改变不了什么。这个时候就可以躲进自然中，在一个阳光明媚的日子里，躺在草地或是海滩，甚至是公园里的一张凳子上，你就会发现，自然在无限的包容你。它不会埋怨你为什么这么差劲，没有拿到好的分数，没有找到一份好工作，为什么别人能做到的事情你做不到。它只会无声的允许你肆意发泄情绪，或哭或笑，或平静或癫狂，然后让风带走这一切，让夜幕当做柔被安抚你进入梦乡。人们没有理由不热爱自然，每个人都能在自然中得到平静和幸福。那么我们就该像自然包容我们一样包容人类，回到搏击场上去笑着对现实说：“并非所有人都是幸福的，或暴躁或痛苦或无耻。我们包容这样的人存在，因为他们属于我无可控制之事，我热爱人类，这样你就无法击败我。” 这是第一场训练，第二场训练是选择做和不做。人生有很多选择，每次选择也许会改变未来，是好是坏在做选择的时候并不能看见未来，人们通常焦虑着万一做错了选择，走向了坏的未来该怎么办。焦虑的源头其实是害怕自己得不到幸福，更害怕的是与幸福擦肩而过，这无疑是本末倒置。尼采曾说：“你有你的路，我有我的路。至于适合的路、正确的路和唯一的路，这样的路并不存在。”回到选择上来，我们唯一能正确选择的方法是：“当你有机会做出选择，不要让自己后悔。”这句话有个大前提——存在理性。面对选择我们一定不能头脑一热就做决定，信誓旦旦说我绝不后悔，之后若是失败不得以“唉，当时就是太年轻了”为借口，若是偶然成功也不能因此骄傲自满觉得自己是天选之子。 在重大抉择上，我们要理性的分析，得到的结论必须符合自然规律，有没有可能出现的问题，我们能承担这样的风险吗？确定之后我们要眼神坚定的对命运说“是的，我要这么做，是我自己决定的，我不会后悔，如果无数次回到今天做决定的时候，答案是依旧不变！”人们若是尝到过一次“选择大于努力”的甜头后，会一直期望总是做出正确的选择，这无异于赌徒拿着全部的家当在赌桌上期望着一夜暴富，所有、或一无所有。这样的赌徒是害怕失败又痴迷于选择的人，这样的人生是失控的。正如赛涅卡所说“宁愿被命运领着走，也不愿被命运拖着走”。我们理性的做出选择后，就不需要在意后面的事情了，顺其自然，很多事情都是命中注定，交给时间和命运吧，不要害怕，往前走便是了。最差的结果也只是我们在搏击台上又被揍了一拳，疼但不致命。一次次被打击不是因为我们有什么爱好受虐的心理，而是在捶打正在成为利剑的我们，一次次失败吸取教训会让我们与理想中的自己更进一步。这是第三场训练——避免错误和匆忙做出判断。 好了，这是我人生中必须经历的三场训练，它每时每刻都能上演，随时准备搏击-搏击结束吸取教训-等待下一次搏击，天呐要持续一辈子。之后呢？我训练这么久是为了什么？为了死后打谁？上帝还是命运？打赢了谁给我颁奖？打输了我要下地狱了，这辈子白干啦？ 回到我们训练的目的上，为什么训练自己——为了得到幸福。什么是幸福，我不是这会儿正在图书馆享受空调、阳光和无忧无虑的一天吗？这样的日子以后都会有，我会一直幸福下去的。错误的！幸福是波动的，像打游戏一样。击杀野怪（搏击台上训练）成功了有短暂的幸福，通过某关卡了（得到美德）有了短暂的幸福。 美德是高贵的，获得高贵需要斗争。没有任何不经考验和斗争得到的东西，任人性的高贵亦是如此。不要害怕失败，弱者用死亡逃避，强者坦然接受。我们要追求完善的人格，扮演好自己的角色。越是寄予厚望的，要求就会越高。朝着真正的好走去，即使不能到达，也始终不能忘记，获得的是自我的认同和生命的圆满。 幸福的六要素：自然，自强，自足，自洽，自律，自由。人生唯一长久的幸福就是短暂幸福的时间+抵抗不幸的时间。在六要素中，自由是最幸福的，可它需要剩下的五要素做支撑，也是最不容易得到的，五要素还需要我们大量训练出来的技能。现代社会人们常说：等我赚到xxx钱就实现财富自由了，就苦尽甘来幸福了。每个人对自由的定义并不一样，或是财富或是精神，那么问问自己，我追求的自由是什么，我有在追逐的路上吗？人模仿神走向自由。 现在我告诉你幸福的唯一答案——“成为最好的自己”。那你告诉我，理想的自己，是什么样的？我想要一套房子，一辆车，想去希腊、镰仓、巴厘岛。 为什么？我想有个固定安全的住所，这样我感到很幸福；想能增加行走速度可以遮风挡雨的工具，这样我感到很幸福；想去世界看看，体验我的人生，这样我感到很幸福！ 你的幸福是对财富的追求？你说的这些幸福都要很多钱。不，我这是为了创建宁静的生活，在建造和得到的中我都能获取幸福，我认为这是值得的！ 你为了自己的幸福做了什么？确定了自己的大方向，选择了工程师作为我的工作来换取购买幸福的方式。为了成为工程师我努力学习相关知识，读书和实践相结合，不畏惧任何失败，训练生活与职场上不平衡的调节和做选择。剩下的，顺其自然。 很好，当你有机会做出选择的时候，不要让自己后悔。不要害怕，往前走，我在未来等你告诉我这段故事。","link":"/2025/03/23/%E8%AE%BA%E5%B9%B8%E7%A6%8F%E2%80%94%E2%80%94%E6%96%AF%E5%A4%9A%E8%91%9B%E4%B8%BB%E4%B9%89/"},{"title":"马克思主义原理期末复习","text":"正确率应该在85%以上，只有选择题 尽量使用网页打开文件，实在打不开点击备份试试看。","link":"/2022/12/07/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86%E9%A2%98%E7%9B%AE/"},{"title":"量子力学","text":"这个是我们专业学习的《理论物理基础导论》前面几章的一些知识点，不算多，也不算太难。里面可能有错误的地方我忘记修正或者没有发现的，请及时联系我修改。 若无法显示PDF文件，可点击该链接进行下载量子力学 量子力学大题必考题记录问题设把宽为a的一维无限深势阱的坐标原点取在势阱中点，有$$U(x)=\\begin{cases} 0 &amp; (\\left | x \\right | &lt;\\frac{a}{2} ) \\ \\infty &amp; (\\left | x \\right | \\ge \\frac{a}{2} )\\end{cases}$$ 试通过具体解定态薛定谔方程，证明势阱中粒子的波函数为：$$\\Psi _n=\\begin{cases} \\sqrt{\\frac{2}{a}}\\cos\\frac{n\\pi}{a}x &amp; n=1,3,5… \\ \\sqrt{\\frac{2}{a}}\\sin\\frac{n\\pi}{a}x &amp; n=2,4,6…\\end{cases}$$ 粒子的能量为$$ E_n=\\frac{\\pi^2\\hbar^2}{2\\mu a^2}n^2\\qquad n=1,2,3,4…$$ 答案证明：势函数与时间无关，是定态问题。 由于是无限深势阱，粒子不可能到达阱外，因此在阱外$$\\Psi(x)=0,\\quad \\left | x \\right | \\ge \\frac{a}{2}$$ 在阱内，波函数满足定态薛定谔方程$$-\\frac{\\hbar^2}{2\\mu}\\Psi^{‘’}(x)=E\\Psi(x)\\quad \\left | x \\right |\\le \\frac{a}{2} $$ 上式可变形为：$$\\Psi^{‘’}(x)+\\frac{2\\mu E}{\\hbar^2}\\Psi(x)=0$$ 令$k^2=\\frac{2\\mu E}{\\hbar^2}$，则方程化为：$$\\Psi^{‘’}+k^2\\Psi(x)=0$$ 该方程的通解为：$$\\Psi(x)=A\\sin kx+B\\cos kx$$ 在边界上，波函数应满足连续性条件，即$$\\Psi(x)\\bigg|{x=-\\frac{a}{2}}^{}=0$$$$\\Psi(x)\\bigg|{x=+\\frac{a}{2}}^{}=0$$ 将通解代入有$$-A\\sin \\frac{ka}{2}+B\\cos \\frac{ka}{2}=0$$$$A\\sin \\frac{ka}{2}+B\\cos \\frac{ka}{2}=0$$ 由此可得$$A\\sin \\frac{ka}{2}=0$$$$B\\cos \\frac{ka}{2}=0$$ A和B不能同时为0，否则解无意义。$A\\ne 0$则必有$$\\sin \\frac{ka}{2}=0\\Rightarrow k_n=\\frac{n\\pi}{a} \\quad n=2,4,6…$$ $B\\ne 0$则必有：$$\\cos \\frac{ka}{2}=0\\Rightarrow k_n=\\frac{n\\pi}{a} \\quad n=1,3,5…$$ 由此可得方程的解为$$\\Psi _n(x)=\\begin{cases} B\\cos \\frac{n\\pi}{a}x &amp; n=1,3,5… \\ A\\sin \\frac{n\\pi}{a}x &amp; n=2,4,6…\\end{cases}$$ 由归一化条件$$A^2\\int_{-\\frac{a}{2}}^{\\frac{a}{2}} (\\sin \\frac{n\\pi }{a}x)^2dx=A^2\\frac{a}{2}=1 $$$$B^2\\int_{-\\frac{a}{2}}^{\\frac{a}{2}} (\\cos \\frac{n\\pi }{a}x)^2dx=B^2\\frac{a}{2}=1 $$ 解得$$A=B=\\sqrt{\\frac{2}{a}}$$ 故在阱内的波函数为$$\\Psi_n(x)=\\begin{cases} \\sqrt{\\frac{2}{a}}\\cos \\frac{n\\pi }{a}x &amp; n=1,3,5… \\ \\sqrt{\\frac{2}{a}}\\sin \\frac{n\\pi }{a}x &amp; n=2,4,6… \\\\end{cases}$$ 粒子的能量$$E_n=\\frac{k^2\\hbar^2}{2\\mu}=\\frac{\\pi^2\\hbar^2}{2\\mu a^2}n^2 \\quad n=1,2,3…$$ 波函数的两个表达式还能统一成一个表达式$$\\Psi_n(x)=\\sqrt{\\frac{2}{a}}\\sin \\frac{n\\pi}{a}(x+\\frac{a}{2}),\\quad n=1,2,3…$$ 书中例题与习题不同的是将坐标原点取在阱势的左边界上，其解为$$\\Psi_n(x)=\\sqrt{\\frac{2}{a}}\\sin \\frac{n\\pi}{a}x \\quad n=1,2,3…$$ 因此只要作坐标平移代换$x=x_1+\\frac{a}{2}$，将坐标原点移到势阱中心，立即可得到习题的结果","link":"/2022/10/25/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"}],"tags":[{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"代码","slug":"代码","link":"/tags/%E4%BB%A3%E7%A0%81/"},{"name":"FIFO","slug":"FIFO","link":"/tags/FIFO/"},{"name":"命令","slug":"命令","link":"/tags/%E5%91%BD%E4%BB%A4/"},{"name":"数字IC设计","slug":"数字IC设计","link":"/tags/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/"},{"name":"数字IC验证","slug":"数字IC验证","link":"/tags/%E6%95%B0%E5%AD%97IC%E9%AA%8C%E8%AF%81/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"个人","slug":"个人","link":"/tags/%E4%B8%AA%E4%BA%BA/"},{"name":"旅行","slug":"旅行","link":"/tags/%E6%97%85%E8%A1%8C/"},{"name":"思考","slug":"思考","link":"/tags/%E6%80%9D%E8%80%83/"}],"categories":[{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"数字IC工程师脑袋里有什么","slug":"数字IC工程师脑袋里有什么","link":"/categories/%E6%95%B0%E5%AD%97IC%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%84%91%E8%A2%8B%E9%87%8C%E6%9C%89%E4%BB%80%E4%B9%88/"},{"name":"个人","slug":"个人","link":"/categories/%E4%B8%AA%E4%BA%BA/"}],"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"留言板","text":"阁下可以在此处尽情畅言，学习、生活都可以，对我的Blog整体评价也可以在此处留言。有什么问题可以提出，做的不好的地方请原谅，并及时告知我定尽快修改。","link":"/messageboard/index.html"},{"title":"友情链接","text":"暂定","link":"/link/index.html"},{"title":"٩(๑•̀ω•́๑)۶ 这里是我的个人介绍","text":"欢迎你好呀！欢迎来到我的博客！ 目前我还是一名博客的初学者，很多东西还正在学习，以后会把我的博客弄的更好看的！^o^ 这里主要是我用于分享的地方，每天学习一点点相信我的博客一定会非常棒的！ 继续努力，加油加油哈哈哈！目标是成为最自由的工程师👩‍💻！！！！ 自我介绍👻我是Hau，也可以叫我小波，目前在广东读书，电子科学与技术大四学生 兴趣爱好 喜欢一个人旅游，citywalk，去过好多座城市，最喜欢上海和澳门下图制作源自微信小程序“极简足迹” 11年动漫爱好者，老二次元了，各种类型的番都有看，这几年看的比较少了。最爱《EVA》，没有特别喜欢的动漫角色，因为我全部都要！ 游戏爱好者，喜欢单机休闲小游戏，常玩游戏有《崩坏·星穹铁道》、《文明IV》等，各类游戏都有尝试。(不过我晕3D，不喜欢在电脑上玩FPS游戏和Minecraft) 海边爱好者，极度喜欢海天一色的美景，若是闲下来定会去海边坐着，什么都不做，也能感受到灵魂的洗涤。 摄影爱好者(业余)，就是喜欢到处拍拍拍，我觉得好看就行了，还不错吧。 纯音乐爱好者，五音不全，乐器不认识，曲名记不住，但是耳朵很有耳力，总能与曲子共鸣，享受精神乐趣。下面是我在spotify创建的歌单的部分歌曲，Instrumental真的超赞的。 联系方式下面是我的一些联系方式： 这是我的Github: Hau，一般用于储存我的代码和项目； 这是我的知乎: 杭雨雾里沙，一般用于写一些思考类的文章 这是我的邮箱:yep6344@gmail.com 这是我的QQ：3203488420 欢迎留言！","link":"/about_me/index.html"}]}